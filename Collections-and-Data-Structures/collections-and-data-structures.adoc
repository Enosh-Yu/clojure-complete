= 컬렉션과 자료구조
:source-highlighter: coderay
:source-language: clojure
:sectnums:
:icons: font
:imagesdir: ../img
:linkcss:
:stylesdir: ../
:stylesheet: my-asciidoctor.css
:toc: right

[quote, Alan J. Perlis, Epigrams on Programming]
It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.

단순 자료형을 설명하였다. 이 장에서는 복합 자료형 혹은 컬렉션을 설명한다.

== 자료구조(Data Structures)

컬렉션은 여러 데이터를 하나의 덩어리로 묶어서 다루기 위한 것이다. 클로저는 컬렉션으로 사용할 수 있는 자료구조를 제공하는데 다음과 같은 특징을 갖는다.

.클로저 자료구조의 특징
* 불변값이다(Immutable)
* 존속적이다(Persistent)
* 구조의 공유(Structural Sharing)
* 동등 비교는 값으로만 한다.
* hash 값을 제공한다.
* 스레드 안전하다(thread-safe)
* 추상(Abstraction)으로 표현된다.
* java.lang.Iterable을 구현한다.
* java.util.Collection의 일부 read-only 부분을 구현한다.

컬렉션으로서 데이터를 어떤 방식로 묶느냐에 따라 클로저는 다음 4개의 자료구조를 제공한다.

.클로저 자료구조
리스트::
* 가장 단순한 자료구조로 순차 접근이 가능하다.
* 단일 연결 리스트.
* 구현 클래스 : clojure.lang.PersistentList
벡터::
* 임의 접근이 가능하다.
* 다른 언어에서의 배열 정도에 해당한다.
* 구현 클래스 : clojure.lang.PersistentVector
맵::
* 키-값 쌍으로 구성된다.
* 파이썬의 dictionary, 루비의 Hash에 해당한다.
* 구현 클래스 : clojure.lang.PersistentArrayMap
집합::
* 중복되지 않는 요소를 갖는다.
* 구현 클래스 : clojure.lang.PersistentHashSet


=== 자료구조 리터럴(Literals)

자료구조 리터럴은 자료구조를 어떻게 표기하는지를 나타내는 것이다. 다음은 리스트, 벡터, 집합, 맵의 리터럴 표기를 보여준다.

[source]
----
;;; 자료구조는 여러가지 자료형의 단순값을 요소로 취할 수 있다.

'(1 1.0 :a \a "a")  ; 리스트 리터럴 <1>
;=> (1 1.0 :a \a "a")

[1 1.0 :a \a "a"]   ; 벡터 리터럴   <2>
;=> [1 1.0 :a \a "a"]

{:a 1 :b 2 :c 3}    ; 맵 리터럴     <3>
;=> {:a 1, :c 3, :b 2} <4>

#{1 1.0 :a \a "a"}  ; 집합 리터럴   <5>
;=> #{1.0 1 :a \a "a"} <6> <7>
----
<1> 리스트 : 괄호 ()로 묶고, 앞에 인용 기호를 붙인다.
<2> 벡터  : 대괄호 []로 묶는다.
<3> 맵    : 중괄호 {)로 묶는다.
<4> 리스트와 벡터와는 달리 맵은 요소간에 순서가 없다. 그래서 정의했을 때의 순서가 보장되지 않는다.
<5> 집합  : #이 앞에 붙은 중괄호 #{}로 묶는다.
<6> 집합도 맵과 마찬가지로 요소간에 순서가 없다.
<7> 쉼표(,)는 스페이스로 취급되기 때문에, 있으나 없으나 상관없다.



.리스트는 특별하다
****
클로저에서 리스트는 좀 특별하다. 리스트는 데이타를 묶는 컬렉션으로서의 역할도 있지만, 다른 리스프(LISP)언어에서처럼 함수를 호출하는 역할도 있다. 리스트가 함수를 호출하는 역할은 하지 않고, 다만 데이타를 묶는 역할만 하도록 하기 위해 인용 기호(')를 괄호 앞에 붙인다.

[source]
----
(+ 1 2) ; 첫 요소인 +를 함수로서 호출한다.
;=> 3

(1 2 3) ; 첫 요소인 1을 함수로서 호출한다.
;; 하지만 1은 함수가 아니라서 예외가 발생한다.
;>> ClassCastException java.lang.Long cannot be cast to clojure.lang.IFn

;; 인용부호(')를 붙이면 리스트는 첫 요소를 함수로 호출하는 역할을 하지 않는다.
'(1 2 3) ; 1을 함수로서 호출하지 않는다.
;; 단지 컬렉션으로서의 역할만 한다.
;=> (1 2 3)

'(+ 1 2) ; +를 함수로서 호출하지 않는다.
;; +는 리스트의 첫 요소로서 포함된다.
;=> (+ 1 2)
----


하지만 데이타가 없는 빈 리스트는 함수로서 취급할 요소가 없으므로 인용 기호(')가 없어도 예외가 발생하지 않는다.

[source]
----
(= () '())
;=> true
----
****

자료구조는 물론 여러 컬렉션을 요소로 취할 수 있다.

[source]
----
'((1) [1] #{1} {:a 1})  ; 리스트 안에 리스트, 벡터, 집합, 맵이 있다. <1>
;=> ((1) [1] #{1} {:a 1})

['(1) [1] #{1} {:a 1}]  ; 벡터 안에 리스트, 벡터, 집합, 맵이 있다.
;=> [(1) [1] #{1} {:a 1}]

{'(1) [1] #{1} {:a 1}}  ; 맵 안에 리스트, 벡터, 집합, 맵이 있다.
;=> {(1) [1] #{1} {:a 1}}

#{'(1) [1] #{1} {:a 1}} ; 집합 안에 리스트, 벡터, 집합, 맵이 있다.
;=> #{[1] #{1} {:a 1}}  <2>
----
<1> 내포된 리스트에는 인용부호(')를 하지 않아도 된다.
<2> ```(= '(1) [1])``` 이기 때문에, [1]만 남는다.

맵의 경우에는 같은 키가 중복되는 것을 허용하지 않는다. 같은 키가 있으면 예외가 발생한다.

[source]
----
{:a 1 :a 2} ; 키 :a가 중복
;; 예외 발생
;>> IllegalArgumentException Duplicate key: :a
----

집합은 같은 값이 중복되는 것을 허용하지 않는다. 같은 값이 있으면 예외가 발생한다.

[source]
----
#{1 2 3 3} ; 3이 중복
;; 예외 발생
;>> IllegalArgumentException Duplicate key: 3
----

NOTE: 위의 두 코드를 보면 맵이나 집합이나 중복이 있으면 Duplicate key라는 예외가 발생한다는 것을 알 수 있다.
      이 예외는 key가 중복되어서 발생한 것인데, 맵은 하나의 키가 여러 값을 가질 수 없으니 이해가 된다.
      하지만 집합은 키가 아니라 값이 중복된 것인데, 왜 Dubplicate key라는 예외가 발생할까?
      이것은 집합의 내부 구현은 맵과 같다는 것을 의미한다. 즉 집합은 키와 값이 같은 맵으로 볼 수 있다는 것이다.
      예를 들어, #{1 2 3}은 {1 1 2 2 3 3}과 같다고 볼 수 있는 것이다.

맵은 키-값 쌍이 맞지 않으면 예외가 발생한다. 맵 안에는 항상 짝수 개의 형식(form)이 있어야 한다.

[source]
----
{:a 1 :b} ; 키 :b에 해당하는 값이 없다.
;; 예외 발생
;>> RuntimeException Map literal must contain an even number of forms
----

컬렉션은 구조화된 데이터의 묶음이지만, 또한 그 자체로 값(Value)이다. 따라서 데이타가 없는 컬렉션, 즉 빈(empty) 컬렉션은 값(Value)이지, 아무것도 없음을 의미하는 nil과는 다르다.

[source]
----
(not=  () nil) ;=> true ; empty list
(not=  [] nil) ;=> true ; empty vector
(not= #{} nil) ;=> true ; empty set
(not=  {} nil) ;=> true ; empty map
----

=== 자료구조 생성함수

리스트, 벡터, 집합, 맵 등 각 자료구조를 동적으로 생성하는 함수들이 있다.

[source]
----
(list 1 2 3)            ; 리스트 생성
;=> (1 2 3)

(vector 1 2 3)          ; 벡터 생성
;=> [1 2 3]

(hash-map :a 1 :b 2)    ; 맵 생성    <1>
;=> {:a 1 :b 2}

(hash-set 1 2 3)        ; 집합 생성   <2>
;=> #{1 2 3}
----
<1> map은 전혀 다른 함수이다. 뒤에서 설명한다.
<2> set은 다른 컬렉션을 집합으로 바꾸는 함수이다. 뒤에서 설명한다.


``hash-map``과 ``hash-set``은 중복이 있으면 제거한다.

[source]
----
(hash-set 1 2 3 3 2)
;=> #{1 2 3}

(hash-map :a 1 :b 2 :a 10)
;=> {:a 10 :b 2}
----

=== seq

클로저에서 모든 컬렉션은 시퀀스로 취급될 수 있다. 시퀀스는 head와 tail 두 개로 구성되는데, tail은 또 다른 시퀀스이다. +
클로저에서의 시퀀스에 대해서는 뒤에서 보다 더 자세히 살펴볼 것이다. +
`seq` 함수는 컬렉션의 시퀀스를 반환한다.

[source]
----
(seq '(1))  ;=> (1)
(seq [1])   ;=> (1)
(seq #{1})  ;=> (1)
(seq {:a 1} ;=> ([:a 1])
----


=== cons

`cons` 함수는 두 개의 인수를 받는다. 첫 번째 인수는 head, 컬렉션인 두 번째 인수는 tail로 하는 새로운 seq를 반환한다.

[source]
----
(cons 0 '(1 2 3))  ; 리스트
;=> (0 1 2 3)

(cons 0 [1 2 3])   ; 벡터
;=> (0 1 2 3)

(cons 0 {:a 1})    ; 맵
;=> (0 [:a 1])

(cons 0 #{1 2 3})  ; 집합
;=> (0 1 2 3)
----

=== conj

`conj` 함수는 컬렉션인 첫 번째 인수에 두 번째 인수를 추가한 새로운 컬렉션을 반환한다.
``conj``는 입력 컬렉션의 형태가 보존되며, 요소 추가는 해당 컬렉션에 가장 효율적인 방식으로 처리된다.

[source]
----
(conj '(1 2 3) 0)    ; 리스트의 경우 맨 앞에 추가된다.
;=> (0 1 2 3)

(conj [1 2 3] 0)     ; 벡터의 경우 맨 뒤에 추가된다.
;=> [1 2 3 0]

(conj {:a 1} [:b 2]) ; 맵은 키-값 쌍의 튜플로 추가된다.
;=> {:a 1 :b 2}

(conj #{1 2 3} 0)    ; 집합의 경우 추가되어도 순서는 없다.
;=> #{0 1 2 3}
----

=== into


=== get/nth



=== 자료구조 진위 함수(predicates)

다음은 각 자료구조를 확인하는 진위함수들이다.

[source]
----
(list?  '(1))  ;=> true  <1>
(vector? [1])  ;=> true  <2>
(map?    {1})  ;=> true  <3>
(set?   #{1})  ;=> true  <4>
----
<1> list?는  IPersistentList 구현 여부를 확인한다.
<2> vector?는 IPersistentVector 구현 여부를 확인한다.
<3> map?은 IPersistentMap 구현 여부를 확인한다.
<4> set?은 IPersistentSet 구현 여부를 확인한다.


[cols="^.^,.^v,.^v,.^v,.^v", options="header"]
|===

|        ^|리스트    ^|벡터     ^|집합           ^|맵

|리터럴    | '(1 2 3) | [1 2 3] | #{1 2 3} | {:a 1 :b 2}

|클래스
|clojure.lang.
PersistentList
|clojure.lang.
PersistentVector
|clojure.lang.
PersistentSet
|clojure.lang.
PersistentMap

|진위 함수
|list?
|vector?
|set?
|map?

|인터페이스
|IPersistentList
|IPersistentVector
|IPersistentSet
|IPersistentMap

|생성 함수
|(list 1 2 3)
;\=> (1 2 3)
|(vector 1 2 3)
;\=> [1 2 3]
|(hash-set 1 2 3)
;\=> #{1 2 3}
|(hash-map :a 1 :b 2)
;\=> {:a 1 :b 2}

|cons
|(cons 0 '(1 2 3))
;\=> (0 1 2 3)
|(cons 0 [1 2 3])
;\=> (0 1 2 3)
|(cons 0 #{1 2 3})
;\=> (0 1 2 3)
|(cons :b {:a 1})
;\=> (:b [:a 1])

|conj
|(conj '(1 2 3) 0)
;\=> (0 1 2 3)
|(conj [1 2 3] 0)
;\=> [1 2 3 0]
|(conj #{1 2 3} 0)
;\=> #{0 1 2 3}
|(conj {:a 1} [:b 2])
;\=> {:b 2 :a 1}

|===



=== 리스트
리스트는 클로저에서 가장 단순한 컬렉션이다. 리스트는 단일 연결 리스트여서 순차 접근만 된다.

==== 리스트 리터럴
리스트 리터럴은 인용기호를 앞에 붙인 괄호 '()로 둘러싸서 만든다.

[source]
----
'(1 2 3)
;=> (1 2 3)
----

클로저의 리스트의 요소에는 다양한 타입의 값들이 올 수 있다.

[source]
----
'(1 :a \a "a" 1.1 1/2)
;=> (1 :a \a "a" 1.1 1/2)
----

==== 리스트 만들기
`list` 함수로 리스트를 동적으로 만들수 있다.

[source]
----
(list 1 2 3)
;=> (1 2 3)
----

``cons``는 기존 리스트의 head에 원소를 추가해서 새 리스트를 만든다.

[source]
----
(cons 0 '(1 2 3))
;=> (0 1 2 3)

(cons '(0) '(1 2 3))
;=> ((0) 1 2 3)
----

``conj``도 기존 리스트의 처음에 원소를 추가해서 새 리스트를 만든다. +
그러나 파라미터의 순서가 다르다.

[source]
----
(conj '(1 2 3) 0)
;=> (0 1 2 3)
----

==== 리스트 접근
`first`, `second`, `last` 함수를 사용해 리스트의 요소를 가져올 수 있다.

[source]
----
(first '(1 2 3))
;=> 1
(second '(1 2 3))
;=> 2
(last '(1 2 3))
;=> 3
----

``rest`` 함수는 첫 번째 요소를 제외한 나머지 리스트가 반환된다.

[source]
----
(rest '(1 2 3))
;=> (2 3)
----

