= 컬렉션과 자료구조
:source-highlighter: coderay
:source-language: clojure
:sectnums:
:icons: font
:imagesdir: ../img
:linkcss:
:stylesdir: ../
:stylesheet: my-asciidoctor.css
:toc: right

[quote, Alan J. Perlis, Epigrams on Programming]
It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.

단순 자료형을 설명하였다. 이 장에서는 복합 자료형 혹은 컬렉션을 설명한다.

== 자료구조(Data Structures)

컬렉션은 여러 데이터를 하나의 덩어리로 묶어서 다루기 위한 것이다. 클로저는 컬렉션으로 사용할 수 있는 자료구조를 제공하는데 다음과 같은 특징을 갖는다.

.클로저 자료구조의 특징
* 불변값이다(Immutable)
* 존속적이다(Persistent)
* 구조의 공유(Structural Sharing)
* 동등 비교는 값으로만 한다.
* hash 값을 제공한다.
* 스레드 안전하다(thread-safe)
* 추상(Abstraction)으로 표현된다.
* java.lang.Iterable을 구현한다.
* java.util.Collection의 일부 read-only 부분을 구현한다.

컬렉션으로서 데이터를 어떤 방식로 묶느냐에 따라 클로저는 다음 4개의 자료구조를 제공한다.

.클로저 자료구조
리스트::
* 가장 단순한 자료구조로 순차 접근이 가능하다.
* 단일 연결 리스트.
* 구현 클래스 : clojure.lang.PersistentList
벡터::
* 임의 접근이 가능하다.
* 다른 언어에서의 배열 정도에 해당한다.
* 구현 클래스 : clojure.lang.PersistentVector
맵::
* 키-값 쌍으로 구성된다.
* 파이썬의 dictionary, 루비의 Hash에 해당한다.
* 구현 클래스 : clojure.lang.PersistentArrayMap
집합::
* 중복되지 않는 요소를 갖는다.
* 구현 클래스 : clojure.lang.PersistentHashSet


=== 자료구조 리터럴(Literals)

자료구조 리터럴은 자료구조를 어떻게 표기하는지를 나타내는 것이다. 다음은 리스트, 벡터, 집합, 맵의 리터럴 표기를 보여준다.

[source]
----
;;; 자료구조는 여러가지 자료형의 단순값을 요소로 취할 수 있다.

'(1 1.0 :a \a "a")  ; 리스트 리터럴 <1>
;=> (1 1.0 :a \a "a")

[1 1.0 :a \a "a"]   ; 벡터 리터럴   <2>
;=> [1 1.0 :a \a "a"]

{:a 1 :b 2 :c 3}    ; 맵 리터럴     <3>
;=> {:a 1, :c 3, :b 2} <4>

#{1 1.0 :a \a "a"}  ; 집합 리터럴   <5>
;=> #{1.0 1 :a \a "a"} <6> <7>
----
<1> 리스트 : 괄호 ()로 묶고, 앞에 인용 기호를 붙인다.
<2> 벡터  : 대괄호 []로 묶는다.
<3> 맵    : 중괄호 {)로 묶는다.
<4> 리스트와 벡터와는 달리 맵은 요소간에 순서가 없다. 그래서 정의했을 때의 순서가 보장되지 않는다.
<5> 집합  : #이 앞에 붙은 중괄호 #{}로 묶는다.
<6> 집합도 맵과 마찬가지로 요소간에 순서가 없다.
<7> 쉼표(,)는 스페이스로 취급되기 때문에, 있으나 없으나 상관없다.



.리스트는 특별하다
****
클로저에서 리스트는 좀 특별하다. 리스트는 데이타를 묶는 컬렉션으로서의 역할도 있지만, 다른 리스프(LISP)언어에서처럼 함수를 호출하는 역할도 있다. 리스트가 함수를 호출하는 역할은 하지 않고, 다만 데이타를 묶는 역할만 하도록 하기 위해 인용 기호(')를 괄호 앞에 붙인다.

[source]
----
(+ 1 2) ; 첫 요소인 +를 함수로서 호출한다.
;=> 3

(1 2 3) ; 첫 요소인 1을 함수로서 호출한다.
;; 하지만 1은 함수가 아니라서 예외가 발생한다.
;>> ClassCastException java.lang.Long cannot be cast to clojure.lang.IFn

;; 인용부호(')를 붙이면 리스트는 첫 요소를 함수로 호출하는 역할을 하지 않는다.
'(1 2 3) ; 1을 함수로서 호출하지 않는다.
;; 단지 컬렉션으로서의 역할만 한다.
;=> (1 2 3)

'(+ 1 2) ; +를 함수로서 호출하지 않는다.
;; +는 리스트의 첫 요소로서 포함된다.
;=> (+ 1 2)
----


하지만 데이타가 없는 빈 리스트는 함수로서 취급할 요소가 없으므로 인용 기호(')가 없어도 예외가 발생하지 않는다.

[source]
----
(= () '())
;=> true
----
****

자료구조는 물론 여러 컬렉션을 요소로 취할 수 있다.

[source]
----
'((1) [1] #{1} {:a 1})  ; 리스트 안에 리스트, 벡터, 집합, 맵이 있다. <1>
;=> ((1) [1] #{1} {:a 1})

['(1) [1] #{1} {:a 1}]  ; 벡터 안에 리스트, 벡터, 집합, 맵이 있다.
;=> [(1) [1] #{1} {:a 1}]

{'(1) [1] #{1} {:a 1}}  ; 맵 안에 리스트, 벡터, 집합, 맵이 있다.
;=> {(1) [1] #{1} {:a 1}}

#{'(1) [1] #{1} {:a 1}} ; 집합 안에 리스트, 벡터, 집합, 맵이 있다.
;=> #{[1] #{1} {:a 1}}  <2>
----
<1> 내포된 리스트에는 인용부호(')를 하지 않아도 된다.
<2> ```(= '(1) [1])``` 이기 때문에, [1]만 남는다.

맵의 경우에는 같은 키가 중복되는 것을 허용하지 않는다. 같은 키가 있으면 예외가 발생한다.

[source]
----
{:a 1 :a 2} ; 키 :a가 중복 >> 예외 발생
;>> IllegalArgumentException Duplicate key: :a
----

집합은 같은 값이 중복되는 것을 허용하지 않는다. 같은 값이 있으면 예외가 발생한다.

[source]
----
#{1 2 3 3} ; 3이 중복 >> 예외 발생
;>> IllegalArgumentException Duplicate key: 3
----

NOTE: 위의 두 코드를 보면 집합이나 맵이나 중복이 있으면 Duplicate key라는 예외가 발생한다는 것을 알 수 있다.
      이 예외는 key가 중복되어서 발생한 것인데, 맵은 하나 키가 여러 값을 가질 수 없으니 이해가 된다.
      하지만 집합은 키가 아니라 값이 중복된 것인데, 왜 Duplicate key 예외가 발생할까?
      이것은 집합의 내부 구현은 맵과 같다는 것을 의미한다. 즉 집합은 키와 값이 같은 맵으로 볼 수 있다는 것이다.
      예를 들어, #{1 2 3}은 {1 1 2 2 3 3}과 같다고 볼 수 있는 것이다.

맵은 키-값 쌍이 맞지 않으면 예외가 발생한다. 맵 안에는 항상 짝수 개의 형식(form)이 있어야 한다.

[source]
----
{:a 1 :b} ; 키 :b에 해당하는 값이 없다 >> 예외 발생
;>> RuntimeException Map literal must contain an even number of forms
----

컬렉션은 구조화된 데이터의 묶음이지만, 또한 그 자체로 값(Value)이다. 따라서 데이타가 없는 컬렉션, 즉 빈(empty) 컬렉션도 값(Value)이다. 아무것도 없음을 의미하는 nil과는 다르다.

[source]
----
(not=  () nil) ;=> true ; empty list
(not=  [] nil) ;=> true ; empty vector
(not= #{} nil) ;=> true ; empty set
(not=  {} nil) ;=> true ; empty map
----

=== 자료구조의 생성

리스트, 벡터, 집합, 맵 등 각 자료구조를 동적으로 생성하는 함수들이 있다.

[source]
----
(list 1 2 3)            ; 리스트 생성
;=> (1 2 3)

(vector 1 2 3)          ; 벡터 생성
;=> [1 2 3]

(hash-map :a 1 :b 2)    ; 맵 생성    <1>
;=> {:a 1 :b 2}

(hash-set 1 2 3)        ; 집합 생성   <2>
;=> #{1 2 3}
----
<1> map은 전혀 다른 함수이다. 뒤에서 설명한다.
<2> set은 다른 컬렉션을 집합으로 바꾸는 함수이다. 뒤에서 설명한다.


``hash-map``과 ``hash-set``은 중복이 있으면 제거한다.

[source]
----
(hash-set 1 2 3 3 2)       ; 2와 3이 중복
;=> #{1 2 3}

(hash-map :a 1 :b 2 :a 10) ; :a키가 중복  <1>
;=> {:a 10 :b 2}
----
<1> 키가 중복이 되면 나중의 것이 채택된다. 기존값을 덮어쓴다고 생각하면 된다.


=== seq

클로저에서 모든 컬렉션은 시퀀스로 취급될 수 있다. 시퀀스는 head와 tail 두 개로 구성되는데, tail은 또 다른 시퀀스이다. 클로저에서의 시퀀스에 대해서는 뒤에서 보다 더 자세히 살펴볼 것이다. `seq` 함수는 컬렉션의 시퀀스를 반환한다.
클로저에서 모든 컬렉션은 시퀀스로 취급될 수 있다. 시퀀스는 head와 tail 두 개로 구성되는데, tail은 또 다른 시퀀스이다. 시퀀스에 대해서는 뒤에서 보다 더 자세히 살펴볼 것이다. seq 함수는 컬렉션의 시퀀스를 반환한다.

[source]
----
(seq '(1))  ;=> (1)
(seq [1])   ;=> (1)
(seq #{1})  ;=> (1)
(seq {:a 1} ;=> ([:a 1])
----

=== 자료구조에 요소 추가/삭제

클로저에서는 자료구조에 요소를 추가하거나 삭제하면, 기존 자료구조에 요소가 추가/삭제된 새로운 자료구조가 만들어진다. 기존자료구조는 변하지 않고 그대로 있다. 자료구조는 불변이다(immutable). 이것은 기존 자료구조를 복사한 후 요소를 추가/삭제하는 것처럼 비효율적인 방식은 아니다. 구조 공유(structural sharing)이라는 기법을 통해 아주 효율적으로 불변성을 지원한다.

이러한 자료구조의 불변성은 멀티스레딩에 근본적으로 안전한 프로그래밍을 가능하게 한다.

==== cons

consfootnote:[construct의 준말] 함수는 두 개의 인수를 받아 새로운 seq를 반환한다. 반환된 seq의 head는 첫 번째 인수이고, 컬렉션인 두 번째 인수의 seq가 tail이 된다.

[source]
----
(cons 0 '(1 2 3))  ; 리스트
;=> (0 1 2 3)

(cons 0 [1 2 3])   ; 벡터
;=> (0 1 2 3)

(cons 0 {:a 1})    ; 맵
;=> (0 [:a 1])      <1>

(cons 0 #{1 2 3})  ; 집합
;=> (0 1 2 3)
----
<1> ``(seq {:a 1}) ;=> ([:a 1])`` 이다. 즉 맵의 seq 표현은 키-값 쌍의 튜플들이다.


==== conj

``conj``footnote:[conjoin의 준말]함수는 컬렉션인 첫번째 인수에 두번째 인수를 추가한 새로운 컬렉션을 반환한다.
``conj``는 입력 컬렉션의 형태가 보존되며, 요소 추가는 해당 컬렉션에 가장 효율적이고 효과적인 방식으로 처리된다.

[source]
----
(conj '(1 2 3) 0)    ; 리스트. 맨 앞에 추가된다.
;=> (0 1 2 3)

(conj [1 2 3] 0)     ; 벡터의. 맨 뒤에 추가된다.
;=> [1 2 3 0]

(conj {:a 1} [:b 2]) ; 맵은 키-값 쌍의 벡터 튜플로 추가된다.
;=> {:a 1 :b 2}

(conj #{1 2 3} 0)    ; 집합의 경우 추가되어도 순서는 없다.
;=> #{0 1 2 3}
----

리스트는 순차 접근이기 때문에 맨 마지막이 아니라 맨 앞에 추가되는 것이 효율적이다. 반면 벡터는 임의 접근이기 때문에 맨 마지막에 추가되는 것이 효과적이다.

CAUTION: cons와 conj는 리스트에 요소를 추가할 때는 똑같이 맨 앞에 추가한다. 하지만 벡터에 요소를 추가할 때는 서로 다르게 cons는 맨 앞에, conj는 맨 뒤에 추가한다.

맵의 경우에는 요소를 추가하기 위해서는 키-값 쌍의 벡터로 된 튜풀을 제공해야 한다.


conj는 여러개의 요소를 한 번에 추가할 수 있다.

[source]
----
(conj '(4 5 6) 1 2 3)              ; 리스트.
;=> (3 2 1 4 5 6)

(conj [4 5 6] 1 2 3)               ; 벡터.
;=> [4 5 6 1 2 3)

(conj {:a 1} [:b 2] [:c 3] [:d 4]) ; 맵.
;=> {:d 4 :c 3 :b 2 :a 1}

(conj #{4 5 6} 1 2 3)              ; 집합.
;=> #{1 2 3 4 5 6}
----


==== disj

집합의 경우 ``disj``footnote:[disjoin의 준말] 함수로 요소를 제거한 새로운 집합을 만들 수 있다.

[source]
----
(disj #{1 2 3} 2)    ; 2를 제거.
;=> {1 3}

(disj #{1 2 3} 1 3)  ; 1과 3을 제거.
;=> {2}

(disj #{1 2 3} 4)    ; 제거할 요소가 없다.
;=> {1 2 3}
----

==== assoc

맵의 경우 요소를 추가한 새로운 맵을 만들 때 주로 ``assoc``footnote:[associate의 준말]을 쓴다.

[source]
----
(assoc {} :a 1 :b 2)       ; 빈맵에 여러 요소 추가
;=> {:b 2, :a 1}

(assoc nil :a 1)           ; nil은 빈맵으로 취급된다. <1>
;=> {:a 1}

(assoc {:a 1 :b 2} :a 10 :c 3)  ; 같은 키가 이미 있으면 그 값을 덮어쓴다.
;=> {:c 3, :a 10, :b 2}
----
<1> *_nil이 빈맵으로 취급되는 이유 설명 필요_*

``assoc``은 벡터에도 사용될 수 있다. 이 때 키는 인덱스로 지정할 수 있다. 인덱스는 0부터 시작한다.

[source]
----
(assoc [1 2 3] 0 10)      ; 인덱스 0에 있는 1을 10으로 바꿈.
;=> [10 2 3]

(assoc [1 2 3] 2 '(4 6))  ; 인덱스 2에 있는 마지막 값인 3을 '(4 6)으로 바꿈.
;=> [1 2 (4 6)]

(assoc [1 2 3] 3 10)      ; 인덱스 3, 벡터의 끝에 10 추가. <1>
;=> [1 2 3 10]

(assoc [1 2 3] 4 10)      ; 지정한 인덱스가 없다 >> 예외 발생 <2>
;>> java.lang.IndexOutOfBoundsException
----
<1> *_맨 마지막은 끝을 의미하는 nil이 있다._*
<2> 맵의 경우 자동으로 추가되었다.

위에서 보는 것처럼 벡터가 assoc에 대해 동작하는 것을 보면, 벡터는 인덱스를 키로 하는 맵으로 취급할 수 있다.


==== dissoc

맵에서 특정 키를 제거한 새로운 맵을 만들 때 주로 ``dissoc``을 쓴다.

[source]
----
(dissoc {:a 1 :b 2 c: 3} :b)    ; :b 키 제거.
;=> {:a 1, :c 3}


(dissoc {:a 1 :b 2 c: 3} :c :b) : :c와 :b 키 제거.
;=> {:a 1}
----

반면 ``assoc``과는 다르게 ``dissoc``은 벡터에는 사용할 수 없다.

[source]
----
(dissoc [0 1 2] 0)  ; 잘못된 용법 >> 예외 발생
;>> java.lang.ClassCastException
----


==== assoc-in

클로저에서는 벡터와 맵을 특히 많이 쓴다. 그런데 벡터안에 맥이 있거나 혹은 맵안에 벡터가 있는 경우 추가/삭제를 하는 것이 매우 번거로와지는데, 이럴 때 손쉽게 사용할 수 있는 것이 ``assoc-in`` 함수이다. 이때 내포된 컬렉션의 키를 지정하기 위해 키들의 시퀀스를 사용한다.

[source]
----
(def m {:a {:c 1} :b {:d 2}})

(assoc-in m [:a :c] 10)     ; <1>
;=> {:a {:c 10} :b {:d 2}}

(assoc-in m [:b :e] 3)      ; <2>
;=> {:a {:c 1}, :b {:e 3, :d 2}}
----
<1> 두번째 인자로 지정된 값을 세번째 인자로 덮어 쓴다. 두번째 인자 [:a :c]는 대상을 지정하기 위한 키들이다. 즉 :a는 m에서 {:c 1}를 지정하고, :c는 바로 앞에서 지정된 맵인 {:c 1}에서 1을 지정한다. 이렇게 지정된 값을 10으로 덮어쓴다.
<2> 해당 키가 없으면 추가한다.

assoc이 벡터에 대해서도 동작한 것처럼 assoc-in도 벡터에 대해 동작한다.

[source]
----
(assoc-in {:a [1 2 3]} [:a 0] 10)    ; 맵안의 벡터
;=> {:a [10 2 3]}

(assoc-in [{:a 1}] [0 :a] 10)        ; 벡터안의 맵
;=> [{:a 10}]

(assoc-in [[1] [2] [3]] [2 0] 30)    ; 벡터안의 벡터
;=> [[1] [2] [30]]

(assoc-in [[1 1 1]                   ; 2차원 배열
           [1 1 1]
           [1 1 1]] [0 0] 0)
;=> [[0 1 1][1 1 1][1 1 1]]
----

=== 자료구조에서 요소 참조

==== nth

``nth``는 컬렉션에서 지정한 인덱스에 있는 값을 반환한다. 만약 해당 인덱스가 없으면 예외가 발생한다. 인덱스가 없을 때 반환할 수 있는 디폴트값을 세번째 인자로 줄 수 있다.

[source]
----
(nth [1 2 3] 0)      ; 인덱스 0
;=> 1

(nth [1 2 3] 3)      ; 인덱스 3은 없다 >> 예외 발생
;>> java.lang.IndexOutOfBoundsException

(nth [1 2 3] 3 10)   ; 세번째 인자는 디폴트값으로 10
;>> 10
----

``nth``는 순서가 있는 컬렉션들에 대해 동작한다.

[source]
----
(nth '(1 2 3) 2)               ; 리스트  <1>
;=> 3

(nth "abcd" 2)                 ; 문자열
;=> \c

(nth (into-array [1 2 3]) 2)   ; 자바 Long 배열
;=> 3

(type (into-array [1 2 3]))
;=> [Ljava.lang.Long;
----
<1> 리스트의 경우 인덱스가 없어서, 처음부터 하나씩 세면서 찾는다.

하지만 순서가 없는 맵과 집합에는 동작하지 않는다.

[source]
----
(nth {:a 1} 0)   ; 맵에는 인덱스를 지정할 수 없다 >> 예외 발생
;>> java.lang.UnsupportedOperationException

(nth #{1 2 3} 0) ; 집합에는 인덱스를 지정할 수 없다 >> 예외 발생
;>> java.lang.UnsupportedOperationException
----


TIP: 반면 컬렉션에서 특정 요소의 인덱스를 구하려면 indexOf 자바 메소드를 호출하면 된다.
     ``(.indexOf '(1 2 3) 1) ;\=> 0`` +
     ``(.indexOf  [1 2 3] 2)  ;\=> 1`` +
     ``(.indexOf "abcd" "c") ;\=> 2``

==== get

``get``은 맵에서 특정 키에 해당하는 값을 반환한다. 만약 해당키가 없으면 nil을 반환하는데, 디폴트값이 주어졌으면 디폴트값을 반환한다.

[source]
----
(get {:a 1 :b 2} :b)    ; :b 키의 값을 참조
;;=> 2

(get {:a 1 :b 2} :c)    ; :c 키는 없다
;;=> nil

(get {:a 1 :b 2} :c 3)  ; 3은 디폴트값
;;=> 3
----

벡터는 인덱스를 키로 하는 맵으로 취급될 수 있기 때문에, ``get``이 동작한다.

[source]
----
(get [1 2 3] 1)         ; 인덱스 1을 키 1로 사용.
;=> 2

(get [1 2 3] 5)         ; 인덱스 5를 키 5로 사용. 하지만 없다
;=> nil
----

CAUTION: 인덱스가 없는 경우, nth는 예외를 던지고, get은 nil을 반환한다. +
        ``(nth [1 2 3] 5) ;>> java.lang.IndexOutOfBoundsException`` +
        ``(get [1 2 3] 5) ;\=> nil``

하지만 인덱스가 없는 리스트에는 ``get``이 동작하지 않는다.

[source]
----
(get '(1 2 3) 0)
;=> nil

(get '(1 2 3) 1)
;=> nil
----

자바의 맵에도 ``get``은 동작한다.

[source]
----
(get (System/getenv) "SHELL")
;;=> "/bin/bash"

(get (System/getenv) "PATH")
;;=> "/usr/local/bin:/sbin:/usr/sbin:/usr/bin:/bin"
----

==== get-in

맵안의 맵처럼 내포된 맵을 참조하기 위해서는 ``get-in``을 사용한다. 만약 해당값이 없으면 nil을, 디폴트값이 주어지면 디폴트 값을 반환한다.

[source]
----
(def m {:language "clojure"
        :authour {:name "Rich Hickey"
                  :address {:city "Austin" :state "TX"}}})

(get-in m [:authour :name])
;=> "Rich Hickey"

(get-in m [:authour :address :city])
;=> "Austin"

(get-in m [:authour :address :zip-code])
;=> nil

(get-in m [:authour :address :zip-code] "no zip code!")
;=> "no zip code!"
----

``get-in``은 벡터에도 동작한다.

[source]
----
(def v [[:000-00-0000 "TYPE 1" "JACKSON" "FRED"]
        [:000-00-0001 "TYPE 2" "SIMPSON" "HOMER"]
        [:000-00-0002 "TYPE 4" "SMITH" "SUSAN"]])

(get-in v [0 2])
;=> "JACKSON"

(get-in [[0 1 1]
         [1 1 1]
         [1 1 1]] [0 0])
;=> 0
----


==== find

``find``는 맵의 엔트리(entry)를 반환한다.

[source]
----
(find {:a 1 :b 2 :c 3} :a)
;=> [:a 1]

(find [:a :b :c :d] 2)
;=> [2 :c]
----

==== 직접 참조

``get`` 함수를 통하지 않고 직접 벡터, 맵, 집합으로부터 값을 읽을 수 있다. (리스트 제외)

[source]
----
([1 2 3] 1)          ; 인자 1은 인덱스로 동작.
;=> 2

(#{1 2 3} 1)         ; 인자 1은 키로서 동작. <1>
;=> 1

({:a 1 :b 2} :a)     ; :a 키의 값을 읽는다
;=> 1

({:a 1 :b 2} :c)     ; :c 키는 없다.
;=> nil

({:a 1 :b 2} :c 3)   ; 3은 디폴트값. <2>
;=> 3
----
<1> 집합의 경우 이러한 용법은 그 집합에서의 특정값의 존재여부를 확인하는 방법으로 쓰인다. 실제로 상당히 요긴하게 쓰인다.
<2> 맵의 경우, 디폴트값을 줄 수 있다.

이것이 가능한 이유는 클로저에서는 일부 벡터, 맵, 집합이 함수처럼 동작할 수 있기 때문이다.

이러한 자료구조외에 키워드나 심볼등도 함수처럼 동작한다.

[source]
----
(:a {:a 1 :b 2})
;=> 1

('a {'a 1 'b 2})
;=> 1
----

보통 맵의 경우 위와 같은 방식으로 쓰는 것이 더 안전하다. 왜냐하면 함수가 인자로 맵을 받을 때, 때로 그 인자로 맵이 아닌 nil이 전달되는 경우가 심심치 않게 있는데, 그 인자를 함수로 호출하게 되면, nil을 함수로 호출하는 것이 되어 예외가 발생하기 때문이다.

[source]
----
(def m {:a 1 :b 2})

(m :a)
;=> 1

(:a m)
;=> 1

(def m nil)

(m :a)   ; nil은 함수가 아니다 >> 예외 발생
;>> java.lang.NullPointerException

(:a m)   ; nil이 인자로 사용된다  <1>
;=> nil
----
<1> m이 맵이 아니라 nil이면, 아무값도 없다는 의미로 nil을 반환하는 것은 정상적이다.



=== 자료구조 진위 함수(predicates)

다음은 각 자료구조를 확인하는 진위함수들이다.

[source]
----
(list?  '(1))  ;=> true  <1>
(vector? [1])  ;=> true  <2>
(map?    {1})  ;=> true  <3>
(set?   #{1})  ;=> true  <4>
----
<1> list?는  IPersistentList 구현 여부를 확인한다.
<2> vector?는 IPersistentVector 구현 여부를 확인한다.
<3> map?은 IPersistentMap 구현 여부를 확인한다.
<4> set?은 IPersistentSet 구현 여부를 확인한다.


[cols="^.^,.^v,.^v,.^v,.^v", options="header"]
|===

|        ^|리스트    ^|벡터     ^|집합           ^|맵

|리터럴    | '(1 2 3) | [1 2 3] | #{1 2 3} | {:a 1 :b 2}

|클래스
|clojure.lang.
PersistentList
|clojure.lang.
PersistentVector
|clojure.lang.
PersistentSet
|clojure.lang.
PersistentMap

|진위 함수
|list?
|vector?
|set?
|map?

|인터페이스
|IPersistentList
|IPersistentVector
|IPersistentSet
|IPersistentMap

|생성 함수
|(list 1 2 3)
;\=> (1 2 3)
|(vector 1 2 3)
;\=> [1 2 3]
|(hash-set 1 2 3)
;\=> #{1 2 3}
|(hash-map :a 1 :b 2)
;\=> {:a 1 :b 2}

|cons
|(cons 0 '(1 2 3))
;\=> (0 1 2 3)
|(cons 0 [1 2 3])
;\=> (0 1 2 3)
|(cons 0 #{1 2 3})
;\=> (0 1 2 3)
|(cons :b {:a 1})
;\=> (:b [:a 1])

|conj
|(conj '(1 2 3) 0)
;\=> (0 1 2 3)
|(conj [1 2 3] 0)
;\=> [1 2 3 0]
|(conj #{1 2 3} 0)
;\=> #{0 1 2 3}
|(conj {:a 1} [:b 2])
;\=> {:b 2 :a 1}

|===

