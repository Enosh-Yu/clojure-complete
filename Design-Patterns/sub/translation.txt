= 클로저 디자인 패턴
:source-highlighter: coderay
:source-language: clojure
:sectnums!:
:icons: font
:imagesdir: ../img
:linkcss:
:stylesdir: ../
:stylesheet: my-asciidoctor.css

  이 문서는 http://mishadoff.com/blog/clojure-design-patterns/[clojure design patterns]를 저자의 허락을 받아 번역한 것이다.

Quick overview of the classic Design Patterns in Clojure
GOF의 디자인 패턴을 클로저 관점에서 조명하기

[WARNING]
====
Disclaimer: Most patterns are easy to implement because we use dynamic typing, functional programming and, of course, Clojure. Some of them look wrong and ugly. It's okay. All characters are fake, coincidences are accidental.

고지 사항: 클로저는 동적 타입 언어이자 함수형 프로그래밍 언어여서, 대부분의 패턴은 클로저로 쉽게 구현될 수 있다. 일부 패턴 구현은 부적절하고 이상하게 보일 수도 있지만, 큰 문제는 없다. 이 글에 등장하는 인물은 모두 가공의 인물이다. 특정인과 일치할 수도 있지만, 우연일 뿐이다.
====


== Intro
== 도입

[quote,Anonymous 익명의 프로그래머]
____
Our programming language is fucked up. +
That's why we need design patterns.

우리가 사용하는 프로그래밍 언어는 개판이다. +
그것이 디자인 패턴이 필요한 이유이다.
____

Two modest programmers Pedro Veel and Eve Dopler are solving common software engineering problems and applying design patterns.
평범한 두 프로그래머 페드로 빌(Pedro Veel)과 이브 도플러(Eve Dopler)가 흔히 부딪히는 소프트웨어 문제를 해결하며 디자인 패턴을 적용하고 있다.

== Episode 1. Command
== 에피소드 1. 커맨드(Command) 패턴

[sidebar]
....
Leading IT service provider "Serpent Hill & R.E.E" acquired new project for USA customer. First delivery is a register, login and logout functionality for their brand new site.
중견 IT 서비스 회사 Serpent Hill & R.E.E는 미국 소비자들을 대상으로 하는 새로운 프로젝트를 수주했다. 첫 번째로 할 일은 새로운 사이트의 회원 가입과 로그인, 로그아웃을 처리하는 것이다.
....

Pedro: Oh, that's easy. You just need a Command interface...
페드로: 아! 그건 쉬워요. `Command` 인터페이스면 돼요.

[source,java]
----
interface Command {
  void execute();
}
----

Pedro: Every action should implement this interface and define specific execute behaviour.
페드로: 모든 명령 클래스에서 이 인터페이스를 구현하고 자신만의 `execute` 메소드를 정의하면 됩니다.

[source,java]
----
public class LoginCommand implements Command {

  private String user;
  private String password;

  public LoginCommand(String user, String password) {
    this.user = user;
    this.password = password;
  }

  @Override
  public void execute() {
    DB.login(user, password);
  }
}
----

[source,java]
----
public class LogoutCommand implements Command {

  private String user;

  public LogoutCommand(String user) {
    this.user = user;
  }

  @Override
  public void execute() {
    DB.logout(user);
  }
}
----

Pedro: Usage is simple as well.
페드로: 사용법도 간단합니다.

[source,java]
----
(new LoginCommand("django", "unCh@1ned")).execute();
(new LogoutCommand("django")).execute();
----

Pedro: What do you think, Eve?
페드로: 어떻게 생각해요, 이브?

Eve: Why are you using redundant wrapping into LoginCommand and just don't call DB.login?
이브: 바로 ``DB.login``을 호출하지 않고, 굳이 `LoginCommand` 안에 감싸는 거죠?

Pedro: It's important to wrap here, because now we can operate on generic Command objects.
페드로: 여기서 감싸는 것은 중요해요. 그래야 좀 더 다양한  `Command` 객체를 대상으로 작업을 수행할 수 있거든요.

Eve: For what purpose?
이브: 왜 그래야 하죠?

Pedro: Delayed call, logging, history tracking, caching, plenty of usages.
페드로: 지연 호출이나, 로깅, 기록 추적, 캐싱 등 쓸 데가 아주 많죠.

Eve: Ok, how about that?
이브: 알겠어요. 그럼 이건 어때요?

[source]
----
(defn execute [command]
  (command))

(execute #(db/login "django" "unCh@1ned"))
(execute #(db/logout "django"))
----

Pedro: What the hell this hash sign?
페드로: 이 해시(#) 기호는 도대체 뭐죠?

Eve: A shortcut for javaish
이브: 다음의 자바 코드의 단축형으로 보면 돼요.

[source,java]
----
new SomeInterfaceWithOneMethod() {
  @Override
  public void execute() {
    // do
  }
};
----

Pedro: Just like Command interface...
페드로: `Command` 인터페이스처럼 보이네요.

Eve: Or if you want - no-hash solution.
이브: 원한다면, 다음과 같이 해시 기호 없이 구현할 수도 있어요.

[source]
----
(defn execute [command & args]
  (apply command args))

(execute db/login "django" "unCh@1ned")
----

Pedro: And how do you save function for delayed call in that case?
페드로: 이 경우에 지연 호출을 위해 함수를 저장하려면 어떻게 해야 하나요?

Eve: Answer yourself. What do you need to call a function?
이브: 스스로 답해 보시죠. 함수를 호출하려면 무엇이 필요하죠?

Pedro: Its name...
페드로: 함수 이름...

Eve: And?
이브: 그리고?

Pedro: ...arguments.
페드로: ...함수의 인수들.

Eve: Bingo. All you do is saving a pair (function-name, arguments) and call it whenever you want using (apply function-name arguments)
이브: 맞았어요! 단순히 ``function-name``과 ``arguments``를 저장해 두었다가 언제든 원할 때 `(apply function-name arguments)` 형식으로 호출하면 돼요.

Pedro: Hmm... Looks simple.
페드로: 음... 간단해 보이네요.

Eve: Definitely, Command is just a function.
이브: 물론이죠. ``Command``는 단순히 함수일 뿐이니까요.

.단일 메소드 인터페이스는 함수다
....
역주.

위의 커맨드 패턴 예제에서 Command 인터페이스는 execute() 메소드 하나만 있는 인터페이스였다. 우리는 여기서 메소드가 하나인 인터페이스, 즉 단일 메소드 인터페이스의 역할이 무엇인지 곰곰히 생각해 볼 필요가 있다.

단일 메소드 인터페이스가 하는 일은 정확히 무엇일까? 이 인터페이스를 구현한 클래스의 인스턴스들에 대해서 그 인터페이스의 메소드(이 경우 Command 인터페이스의 execute)를 호출하기 위해서이다. 인스턴스들 즉 객체들은 자바에서는 함수의 파라미터로, 함수의 리턴 값으로, 멤버 변수나 지역 변수 그리고 베열이나 컨테이너 등에 저장할 수 있다. 자바는 객체지향 언어인 것이다.

인터페이스를 구현한 객체들을 전달해서 결국 그 인터페이스의 메소드를 호출하는 것이 목적인 것이다. 하지만 그것이 목적이라면 메소드 자체만을 전달하면 좋지 않을까? 왜 부질없이 객체를 다 전달하는가? 그저 우리는 그 객체의 특정 메소드를 호출하는 것이 관심일 뿐인데 말이다. 객체의 다른 부분들은 필요가 없는 것이다. 우리가 필요한 것은 객체가 아니라 함수다!

하지만 자바에서 함수는 1급이 아니다. 오로지 객체만이 파라미터로 리턴값으로, 변수로, 배열이나 컨테이너의 요소로서의 자격을 지닐 뿐이다. 자바에서는 함수를 그런 식으로 다룰 수는 없다.

만일 함수가 1급이라면 커맨드 패턴은 단지 커맨드 역할을 하는 함수를 전달하기만 하면 된다. 이것이 위의 예제에서 보았듯이 정확히 클로저가 하는 것이다. 클로저를 포함한 모든 함수형 언어에서는 다 마찬가지다. 자바에서는 이것이 불가능하기 때문에, 1급인 객체에 메소드를 메달아 전달한 후, 전달받은 측에서는 객체의 메소드를 불러내어 호출하는 것이다.

결국 단일 메소드 인터페이스는, 함수가 1급이 아니기 때문에, 1급인 객체에 함수를 매달아 전달하기 위한, 어쩔 수 없는 자바의 고육지책인 것이다.

커맨드 패턴 이외의 상당수의 디자인 패턴이 1급 함수를 이용하면 매우 단순하게 구현될 수 있다.

(인터페이스 구현에 있어서의 다형성의 측면이 여기서는 고려되지 않았는데, 이것은 전혀 다른 측면의 문제이기 때문이며, 클로저에서는 멀티 메소드라는 방식으로 자바보다 더 강력한 다형성을 지원한다)
....


== Episode 2. Strategy

== 에피소드 2. 전략(Strategy) 패턴

[sidebar]
....
Sven Tori pays a lot of money to see a page with list of users. But users must be sorted by name and users with subscription must appear before all other users. Obviously, because they pay. Reverse sorting should keep subscripted users on top.
스벤 토리(Sven Tori)는 사용자 목록을 담은 페이지를 보는 데 많은 돈을 쓴다. 그런데 사용자는 이름순으로 정렬되어 있어야 하고, 유료 사용자들은 다른 사용자들보다 앞에 나타나야 한다. 그 이유는 돈을 지불하기 때문이다. 역순으로 정렬할 때에도 유료 사용자들은 앞에 나열되어야 한다.
....

Pedro: Ha, just call Collections.sort(users, comparator) with custom comparator.
페드로: 아! 커스텀 비교자(custom comparator)를 제공해서 ``Collections.sort(users, comparator)``를 호출하면 되겠네요.

Eve: How would you implement custom comparator?
이브: 커스텀 비교자는 어떻게 구현하시려고요?

Pedro: You need to take Comparator interface and provide implementation for compare(Object o1, Object o2) method. Also you need another implementation for ReverseComparator
페드로: `Comparator` 인터페이스를 이용해 `compare(Object o1, Object o2)` 메소드를 구현하면 되요. `ReverseComparator` 클래스의 경우에도 마찬가지로 `Comparator` 인터페이스를 구현하면 됩니다.

Eve: Stop talking, show me the code!
이브: 말보다는 코드를 보여 주세요!

[source,java]
----
class SubsComparator implements Comparator<User> {

  @Override
  public int compare(User u1, User u2) {
    if (u1.isSubscription() == u2.isSubscription()) {
      return u1.getName().compareTo(u2.getName());
    } else if (u1.isSubscription()) {
      return -1;
    } else {
      return 1;
    }
  }
}

class ReverseSubsComparator implements Comparator<User> {

  @Override
  public int compare(User u1, User u2) {
    if (u1.isSubscription() == u2.isSubscription()) {
      return u2.getName().compareTo(u1.getName());
    } else if (u1.isSubscription()) {
      return -1;
    } else {
      return 1;
    }
  }
}

Collections.sort(users, new SubsComparator());

Collections.sort(users, new ReverseSubsComparator());
----

Pedro: Could you do the same?
페드로: 클로저로는 어떻게 할 수 있죠?

Eve: Yeah, something like that
이브: 예, 다음과 같이 합니다.

[source]
----
(sort (comparator (fn [u1 u2]
                    (cond
                      (= (:subscription u1) (:subscription u2))
                      (neg? (compare (:name u1) (:name u2)))

                      (:subscription u1)
                      true

                      :else
                      false)))
      users)
----

Pedro: Pretty similar.
페드로: 아주 유사하네요.

Eve: But we can do it better
이브: 하지만 더 간단하게 할 수도 있어요.

[source]
----
;; forward sort
(sort-by (juxt (complement :subscription) :name) users)

;; reverse sort
(sort-by (juxt :subscription :name) #(compare %2 %1) users)
----

Pedro: Oh my gut! Monstrous oneliners.
페드로: 세상에! 달랑 한 줄짜리 코드네요.

Eve: Functions, you know.
이브: 보시다시피, 그냥 함수들일 뿐이죠.

Pedro: Whatever, it’s very hard to understand what’s happening there.
페드로: 어쩃거나, 코드를 이해하기는 매우 어렵네요.

[sidebar]
....
Eve explains juxt, complement and sort-by.
이브는 ``juxt``와 ``complement``, ``sort-by`` 함수에 대해 설명한다.

10 minutes later
10분이 흐른 뒤에
....

Pedro: Very doubtful approach to pass strategy.
페드로: 전략 패턴 자체를 넘어서는 아주 이상한 방식이네요.

Eve: I don’t care, because Strategy is just a function passed to another function.
이브: 상관 없어요. 전략 패턴은 단순히 어떤 함수에 인수로 전달되는 함수일 뿐이니까요.

== Episode 3. State
== 에피소드 3. 상태(State) 패턴

[sidebar]
....
Sales person Karmen Git investigated the market and decided to provide user-specific functionality.

영업 사원 카르멘 깃(Karmen Git)은 시장을 조사한 후, 사용자별 맞춤 기능을 제공하기로 결정했다.
....

Pedro: Smooth requirements.
페드로: 요구 사항이 어렵지는 않네요.

Eve: Let's clarify them.
이브: 요구 사항을 명확하게 해 보죠.

* If user has subscription show him all news in a feed
* 유료 사용자이면 모든 뉴스를 보여준다.

* Otherwise, show him only recent 10 news
* 그렇지 않으면, 최근 10개의 뉴스만을 보여준다.

* If he pays money, add the amount to his account balance
* 돈을 지불하면 그 금액을 그의 계정 잔액에 더한다.

* If user doesn't have subscription and there is enough money to buy subscription, change his state to...
* 무료 사용자의 잔액이 충분하면 상태를 유료 사용자로 변경한다.

Pedro: State! Awesome pattern. First we make a user state enum
페드로: 상태 패턴이네요! 멋진 패턴이죠. 먼저 사용자의 상태를 나타내는 enum을 만듭니다.

[source,java]
----
public enum UserState {
  SUBSCRIPTION(Integer.MAX_VALUE),
  NO_SUBSCRIPTION(10);

  private int newsLimit;

  UserState(int newsLimit) {
    this.newsLimit = newsLimit;
  }

  public int getNewsLimit() {
    return newsLimit;
  }
}
----

Pedro: User logic is following
페드로: ``User``의 로직은 다음과 같습니다.

[source,java]
----
public class User {
  private int money = 0;
  private UserState state = UserState.NO_SUBSCRIPTION;
  private final static int SUBSCRIPTION_COST = 30;

  public List<News> newsFeed() {
    return DB.getNews(state.getNewsLimit());
  }

  public void pay(int money) {
    this.money += money;
    if (state == UserState.NO_SUBSCRIPTION
        && this.money >= SUBSCRIPTION_COST) {
      // buy subscription
      state = UserState.SUBSCRIPTION;
      this.money -= SUBSCRIPTION_COST;
    }
  }
}
----

Pedro: Lets call it
페드로: 호출해 보죠.

[source,java]
----
User user = new User(); // create default user
user.newsFeed(); // show him top 10 news
user.pay(10); // balance changed, not enough for subs
user.newsFeed(); // still top 10
user.pay(25); // balance enough to apply subscription
user.newsFeed(); // show him all news
----

Eve: You just hide value that affects behaviour inside User object. We could use strategy to pass it directly user.newsFeed(subscriptionType).
이브: 행위(behavior)에 영향을 주는 값을 `User` 객체 안에 감추었을 뿐이네요. ``user.newsFeed(subscriptionType)``처럼 전략 패턴을 이용해서 값을 직접 전달할 수도 있지요.

Pedro: Agreed, State is very close to the Strategy. They even have the same UML diagrams. but we encapsulate balance and bind it to user.
페드로: 인정합니다. 상태 패턴은 전략 패턴과 아주 유사하죠. 이 둘은 심지어 UML 다이어그램으로 표현할 때도 같은 모양이예요. 하지만 잔액을 캡술화해서 `user` 객체 안에 묶어 놓은 것은 다르죠.

Eve: I think it achieves the same goal using another mechanism. Instead of providing strategy explicitly, it depends on some state. From clojure perspective it can be implemented the same way as strategy pattern.
이브: 저는 다른 방식을 사용해도 같은 일을 할 수 있다고 생각해요. 그런데 이 방식은, 명시적으로 전략 패턴을 제공하는 대신에, 상태에 의존하는 것이죠. 클로저의 관점에서는 이 패턴을 전략 패턴과 동일한 방법으로 구현할 수 있어요.

Pedro: But successive calls can change object's state.
페드로: 메소드를 여러 번 호출하면, 객체의 상태가 바뀔 수 있는 데도요?

Eve: Correct, but it has nothing to do with Strategy it is just implementation detail.
이브: 맞아요, 하지만 객체의 상태는 전략 패턴과 관련이 없어요. 그것은 단지 구현 상의 한 방법일 뿐이예요.

Pedro: What about "another mechanism"?
페드로: 그럼 다른 방식이란 무엇인가요?

Eve: Multimethods.
이브: 멀티메소드(Multimethods)입니다.

Pedro: Multi what?
페드로: 멀티 뭐라고요?

Eve: Look at this
이브: 다음 코드를 보세요.

[source]
----
(defmulti news-feed :user-state)

(defmethod news-feed :subscription [user]
  (db/news-feed))

(defmethod news-feed :no-subscription [user]
  (take 10 (db/news-feed)))
----

Eve: And pay function it's just a plain function, which changes state of object. We don't like state too much in clojure, but if you wish.
이브: 다음의 `pay` 함수는 객체의 상태를 바꾼다는 점을 제외하면 평범한 함수일 뿐이예요. 클로저에서는 상태를 가능한 한 최소화하려 하지만, 필요할 때는 사용해야겠지요.

[source]
----
(def user (atom {:name "Jackie Brown"
                 :balance 0
                 :user-state :no-subscription}))

(def ^:const SUBSCRIPTION_COST 30)

(defn pay [user amount]
  (swap! user update-in [:balance] + amount)
  (when (and (>= (:balance @user) SUBSCRIPTION_COST)
             (= :no-subscription (:user-state @user)))
    (swap! user assoc :user-state :subscription)
    (swap! user update-in [:balance] - SUBSCRIPTION_COST)))

(news-feed @user) ;; top 10
(pay user 10)
(news-feed @user) ;; top 10
(pay user 25)
(news-feed @user) ;; all news
----

Pedro: Is dispatching by multimethods better than dispatching by enum?
페드로: 멀티메소드를 이용한 디스패치(dispatch)가 enum을 이용한 디스패치보다 더 나은가요?

Eve: No, in this particlular case, but in general yes.
이브: 이 경우에는 그렇지 않지만, 일반적으로는 그렇습니다.

Pedro: Explain, please
페드로: 설명해 주시겠어요?

Eve: Do you know what double dispatch is?
이브: 이중 디스패치(double dispatch)라고 들어 보셨나요?

Pedro: Not sure.
페드로: 잘 모르겠는데요.

Eve: Well, it is topic for Visitor pattern.
이브: 괜찮아요, 그것이 다음에 다룰 방문자 패턴의 주제이거든요.


== Episode 4. Visitor
== 에피소드 4. 방문자(Visitor) 패턴

[sidebar]
....
Natanius S. Selbys suggested to implement functionality which allows users export their messages, activities and achievements in different formats.

나탈리우스 S. 셀비즈(Natanius S. Selbys)는 사용자들이 자신의 메시지와 활동을 다른 포맷으로 내보내는(export) 기능 구현을 제안했다.
....

Eve: So, how do you plan to do it?
이브: 어떻게 하실 생각이세요?

Pedro: We have one hierarchy for item types (Message, Activity) and another for file formats (PDF, XML)
페드로: 항목들(``Message``, ``Activity``)의 계층도와 파일 포멧들(``PDF``, ``XML``)의 계층도가 있는 거죠.

[source,java]
----
abstract class Format { }
class PDF extends Format { }
class XML extends Format { }

public abstract class Item {
  void export(Format f) {
    throw new UnknownFormatException(f);
  }
  abstract void export(PDF pdf);
  abstract void export(XML xml);
}

class Message extends Item {
  @Override
  void export(PDF f) {
    PDFExporter.export(this);
  }

  @Override
  void export(XML xml) {
    XMLExporter.export(this);
  }
}

class Activity extends Item {
  @Override
  void export(PDF pdf) {
    PDFExporter.export(this);
  }

  @Override
  void export(XML xml) {
    XMLExporter.export(this);
  }
}
----

Pedro: That's all.
페드로: 이게 다예요.

Eve: Nice, but how do you dispatch on argument type?
이브: 좋아요, 그런데 인수의 타입에 따른 디스패치는 어떻게 하죠?

Pedro: What the problem?
페드로: 그게 뭐죠?

Eve: Consider this snippet
이브: 다음의 코드를 보시죠.

[source,java]
----
Item i = new Activity();
Format f = new PDF();
i.export(f);
----

Pedro: Nothing suspicious here.
페드로: 이 코드에는 의심스러운 부분이 없어 보이는데요.

Eve: Actually, if you run this code you get UnknownFormatException
이브: 실제로 이 코드를 실행해 보면 ``UnknownFormatException``이 발생해요.

Pedro: Wait...Really?
페드로: 잠깐만요... 정말요?

Eve: In java you can use only single dispatch. That means if you call i.export(f) you dispatches on the actual type of i, not f.
이브: 자바에서는 단일 디스패치만이 가능해요. 다시 말해 ``i.export(f)``를 호출하면, ``i``의 실제 타입에 따라 디스패치 될 뿐 인수인 ``f``는 전혀 고려의 대상이 되지 않아요.

Pedro: I'm surprised. So, there is no dispatch on argument type?
페드로: 놀랍군요. 그러면 인수의 타입에 따른 디스패치는 안된다는 건가요?

Eve: That's what visitor hack for. After you got a dispatch on i type, you additionally call f.someMethod(i) and dispatched on f type.
이브: 그래서 방문자 패턴이 생긴 것이죠. 먼저 `i` 타입에 기반해 디스패치한 후, 다시 ``f.someMethod(i)``를 호출해 ``f``의 타입에 기반해서 디스패치하는 방식으로요.

Pedro: How that looks in code?
이브: 그런 식의 코드는 어떻게 작성하죠?

Eve: You separately define export operations for all types as a Visitor
이브: 모든 타입에 `export` 메소드를 일일이 방문자로 정의하면 됩니다.

[source,java]
----
public interface Visitor {
  void visit(Activity a);
  void visit(Message m);
}

public class PDFVisitor implements Visitor {
  @Override
  public void visit(Activity a) {
    PDFExporter.export(a);
  }

  @Override
  public void visit(Message m) {
    PDFExporter.export(m);
  }
}
----

Eve: Your items change signature to accept different visitors.
이브: 각 아이템은 다른 방문자를 받아들일 수 있도록 인수 형식을 바꾸어 줍니다.

[source,java]
----
public abstract class Item {
  abstract void accept(Visitor v);
}

class Message extends Item {
  @Override
  void accept(Visitor v) {
    v.visit(this);
  }
}

class Activity extends Item {
  @Override
  void accept(Visitor v) {
    v.visit(this);
  }
}
----

Eve: To use it you may call
이브: 그리고 다음과 같은 방식으로 호출합니다.

[source,java]
----
Item i = new Message();
Visitor v = new PDFVisitor();
i.accept(v);
----

Eve: And everything works fine. Moreover, you can add new operations for activities and messages by just defining new visitors and without changing their code.
이브: 모든 것이 제대로 작동합니다. 게다가 Activity와 Message의 코드를 변경하지 않고, 단순히 새로운 방문자를 정의해서 새로운 동작을 추가할 수 있어요.

Pedro: That's really useful. But implementation is tough, it is the same for clojure?
페드로: 정말로 유용하네요. 하지만 구현은 쉽지 않네요. 클로저에서도 마찬가지인가요?

Eve: Not really, clojure supports it natively via multimethods
이브: 그렇지 않아요. 클로저에서는 멀티메소드를 통해 쉽게 구현할 수 있어요.

Pedro: Multi what?
페드로: 멀티 뭐라고요?

Eve: Just follow the code... First we define dispatcher function
이브: 코드를 보시죠. 먼저 디스패처(dispatcher) 함수를 정의합니다.

[source]
----
(defmulti export
  (fn [item format] [(:type item) format]))
----

Eve: It accepts item and format to be exported. Examples:
이브: 이 함수는 ``item``과 ``format``을 인수로 받습니다. 예를 들면,
[source]
----
;; Message item
{:type :message :content "Say what again!"}

;; Activity item
{:type :activity :content "Quoting Ezekiel 25:17"}

;; Formats
:pdf, :xml
----

Eve: And now you just provide a functions for different combinatations, and dispatcher decide which one to call.
이브: 그리고 다음과 같이 다양한 조합의 인수를 받는 함수들을 정의합니다. 그러면 디스패처가 어떤 함수를 호출할지 결정합니다.

[source]
----
(defmethod export [:activity :pdf] [item format]
  (exporter/activity->pdf item))

(defmethod export [:activity :xml] [item format]
  (exporter/activity->xml item))

(defmethod export [:message :pdf] [item format]
  (exporter/message->pdf item))

(defmethod export [:message :xml] [item format]
  (exporter/message->xml item))
----

Pedro: What if unknown format passed?
페드로: 모르는 포맷이 인수로 건네지면 어떻게 하죠?

Eve: We could specify default dipatcher function.
이브: 다음처럼 디폴트 함수를 지정해 줄 수 있어요.

[source]
----
(defmethod export :default [item format]
  (throw (IllegalArgumentException. "not supported")))
----

Pedro: Ok, but there is no hierarchy for :pdf and :xml. They are just keywords?
페드로: 좋습니다. 하지만 ``:pdf``와 ``:xml`` 사이에는 아무런 상하 관계(hierarchy)가 존재하지 않네요. 단순히 키워드일 뿐이잖아요?

Eve: Correct, simple problem - simple solution. If you need advanced features, you could use adhoc hierarchies or dispatch by class.
이브: 맞아요. 단순한 문제여서 해법도 단순해요. 이와 같은 고급 기능이 필요하면 다음과 같이 임의로 계층 관계(hierarchy)를 지정해 줄 수도 있고, `class` 함수를 디스패처로 사용할 수도 있어요.

[source]
----
(derive ::pdf ::format)
(derive ::xml ::format)
----

Pedro: Quadrocolons?!
페드로: 콜론이 두 개 있네요!

Eve: Assume they are just keywords.
이브: 일단은 그냥 키워드와 같다고 생각하세요.

Pedro: Ok.
페드로: 알겠습니다.

Eve: Then you add functions for every dispatch type ::pdf, ::xml and ::format
이브: 그리고 ``::pdf``와  `::xml`, ``::format``에 해당하는 함수들을 다음처럼 추가해 줍니다.

[source]
----
(defmethod export [:activity ::pdf])
(defmethod export [:activity ::xml])
(defmethod export [:activity ::format])
----

Eve: If some new format (i.e. csv) appears in the system
이브: 만약 새로운 포맷 (예를 들면, csv) 처리가 필요하면, 다음과 같이 해 줍니다.

[source]
----
(derive ::csv ::format)
----

Eve: It will be dispatched to ::format function, until you add a separate ::csv function.
이브: `::csv`를 처리하는 함수를 별도로 제공하지 않으면, ``::format``을 처리하는 함수가 이를 처리해 줘요.

Pedro: Seems good.
페드로: 훌륭해 보이네요.

Eve: Definitely, much easier.
이브: 물론이죠. 게다가 훨씬 쉽지요.

Pedro: So, basically, if a language support multiple dispatch, you don't need Visitor pattern?
페드로: 그렇다면, 언어가 기본적으로 다중 디스패치를 지원하면, 방문자 패턴은 필요 없다는 건가요?

Eve: Exactly.
이브: 맞아요.


Episode 5. Template Method
에피소드 5. 템플릿 메소드(Template Method) 패턴

[sidebar]
....
MMORPG Mech Dominore Fight Saga requested to implement a game bot for their VIP users. Not fair.

멕 도미노어 파잇 사거(Mech Dominore Fight Saga) MMORPG 게임에서 VIP 사용자들을 위한 게임 봇(bot)을 구현해야 한다.
....

Pedro: First, we must decide what actions should be automated with bot.
페드로: 먼저 봇으로 어떤 동작을 자동화해야 할지 결정해야겠어요.

Eve: Have you ever played RPG?
이브: RPG 게임 해본 적 있으세요?

Pedro: Fortunately, no
페드로: 다행히, 없어요.

Eve: Oh my... Let's go, I'll show you...
이브: 오, 이런! 가시죠. 보여드릴께요.

2 weeks later
2주 후에

Pedro: ...fantastic, I found epic sword, which has +100 attack.
페드로: 와우, 제가 +100 공격을 할 수 있는 전설의 검을 찾았어요.

Eve: Unbelievable. But now, it's time for bot.
이브: 대단하네요. 하지만 이제 봇을 구현해야 해요.

Pedro: Easy-peasy. We could select following events
페드로: 식은 죽 먹기죠. 다음의 상황을 선택하기로 하죠.

* Battle
* 전투

* Quest
* 임무

* Open Chest
* 상자 열기

Pedro: Characters behave differently in different events, for example mages cast spells in battle, but rogues prefer silent melee combat; locked chests are skipped by most characters, but rogues can unlock them, etc.
페드로: 캐릭터들은 각 상황에서 다르게 행동해요. 예를 들면 마법사(mage)는 전투 상황에서 주문을 겁니다. 하지만 악당(rogue)들은 은밀한 근접전을 선호해요. 잠겨 있는 상자는 대부분의 캐릭터들이 그냥 지나치지만 악당들은 열 수 있어요.

Eve: Looks like ideal candidate for Template Method?
이브: 템플릿 메소드 패턴이 가장 적합한 것 같은데요?

Pedro: Yes. We define abstract algorithm, and then specify differences in subclasses.
페드로: 그래요. 상위 추상 클래스에서 공통의 알고리즘을 정의하고, 하위 클래스에서 각자의 동작을 구현하는 방식이죠.

[source,java]
----
public abstract class Character {
  void moveTo(Location loc) {
    if (loc.isQuestAvailable()) {
      Journal.addQuest(loc.getQuest());
    } else if (loc.containsChest()) {
      handleChest(loc.getChest());
    } else if (loc.hasEnemies()) {
      attack(loc.getEnemies());
    }
    moveTo(loc.getNextLocation());
  }

  private void handleChest(Chest chest) {
    if (!chest.isLocked()) {
      chest.open();
    } else {
      handleLockedChest(chest);
    }
  }

  abstract void handleLockedChest(Chest chest);
  abstract void attack(List<Enemy> enemies);
}
----

Pedro: We've separated to Character class everything common to all characters. Now we can create subclasses, that define how character should behave in specific situation. In out case: handling locked chests and attacking enemies.
페드로: 모든 캐릭터에 공통된 내용은 `Character` 클래스로 분리했습니다. 이제 하위 클래스들을 만들어, 캐릭터들이 특정 상황에서 어떻게 행동하는지를 정의하면 돼요. 잠겨 있는 상자를 다루는 상황과 적을 공격하는 상황의 행동들을 정의해 보죠.

Eve: Let's start with a Mage class.
이브: 마법사 클래스부터 시작하죠.

Pedro: Mage? Okay. He can't open locked chest, so implementation is just do nothing. And if he is attacking enemies, if there are more than 10 enemies, freeze them, and cast teleport to run away. If there are 10 enemies or less cast fireball on each of them.
페드로: 마법사요? 좋습니다. 마법사는 잠긴 상자는 열 수 없어요. 그래서 아무것도 하지 않는 것으로 구현하면 됩니다. 적을 공격할 때는 적의 수가 10명이 넘으면 적들을 움직이지 못하게 하고 공간 이동 주문을 외워 도망칩니다. 10명 이하이면 불덩어리 주문을 외워 공격합니다.

[source,java]
----
public class MageCharacter extends Character {
  @Override
  void handleLockedChest(Chest chest) {
    // do nothing
  }

  @Override
  void attack(List<Enemy> enemies) {
    if (enemies.size() > 10) {
      castSpell("Freeze Nova");
      castSpell("Teleport");
    } else {
      for (Enemy e : enemies) {
        castSpell("Fireball", e);
      }
    }
  }
}
----

Eve: Excellent, what about Rogue class?
이브: 훌륭합니다. 그럼 악당 클래스는요?

Pedro: Easy as well, rogues can unlock chests and prefer silent combat, handle enemies one by one.
페드로: 마찬가지로 쉽습니다. 악당들은 상자를 열 수 있고, 은밀한 근접전을 좋아해서 적들을 한 명씩 처리하죠.

[source,java]
----
public class RogueCharacter extends Character {
  @Override
  void handleLockedChest(Chest chest) {
    chest.unlock();
  }

  @Override
  void attack(List<Enemy> enemies) {
    for (Enemy e : enemies) {
      invisibility();
      attack("backstab", e);
    }
  }
}
----

Eve: Excellent. But how this approach is differrent from Strategy?
이브: 훌륭합니다. 그런데 이 접근법이 전략 패턴과는 어떻게 다르죠?

Pedro: What?
페즈로: 무슨 말씀인지?

Eve: I mean, you redefined behaviour by using subclasses, but in Strategy pattern you did the same: redefined behaviour by using functions.
이브: 제 말은, 이 패턴에서는 하위 클래스에서 동작을 재정의했는데, 전략 패턴에서도 함수를 이용해 동작을 재정의했었죠.

Pedro: Well, another approach.
페드로: 음, 또다른 접근법이라고 할 수 있겠죠.

Eve: State was handled with another approach as well.
이브: 상태 패턴에서도 역시 또 다른 방식으로 처리했었죠.

Pedro: What are you trying to say?
페드로: 무슨 말씀을 하고 싶으신 거죠?

Eve: You are solving the same kind of problem, but change the approach to it.
이브: 같은 종류의 문제를 해결하면서 접근하는 방법만 다르다는 것이죠.

Pedro: How do yo solve this problem using strategy in clojure?
페드로: 클로저에서는 전략 패턴을 이용해 이 문제를 어떻게 해결하나요?

Eve: Just pass a set of specific functions for each character. For example, your abstract move may look like:
이브: 각 캐릭터들의 행동을 정의하는 함수를 그냥 건네주면 돼요. 예를 들면, 추상적인 이동 동작은 대략 다음과 같은 모양일 겁니다:

[source]
----
(defn move-to [character location]
  (cond
    (quest? location)
    (journal/add-quest (:quest location))

    (chest? location)
    (handle-chest (:chest location))

    (enemies? location)
    (attack (:enemies location)))
  (move-to character (:next-location location)))
----

Eve: To add character-specific implementation of methods handle-chest and attack, implement them and pass as an argument.
이브: 각 캐릭터별 ``handle-chest``와 `attack` 메소드를 추가하려면, 그 메소드들을 구현한 후 인수로 전달하면 돼요.

[source]
----
;; Mage-specific actions
(defn mage-handle-chest [chest])

(defn mage-attack [enemies]
  (if (> (count enemies) 10)
    (do (cast-spell "Freeze Nova")
        (cast-spell "Teleport"))
    ;; otherwise
    (doseq [e enemies]
      (cast-spell "Fireball" e))))

;; Signature of move-to will change to
(defn move-to [character location
               & {:keys [handle-chest attack]
                  :or {handle-chest (fn [chest])
                       attack (fn [enemies] (run-away))}}]
  (cond
    (quest? location)
    (journal/add-quest (:quest location))

    (chest? location)
    (handle-chest (:chest location))

    (enemies? location)
    (attack (:enemies location)))
  (move-to character (:next-location location)))
----

Pedro: OMG, what's happening there?
페드로: 이런, 이 코드들이 대체 무엇을 하고 있는 거죠?

Eve: We changed signature of move-to to accept handle-chest and attack functions.
Think of them like optional parameters.
이브: `move-to` 함수의 인수가 ``handle-chest``와 `attack` 함수를 받아들일 수 있도록 변경한 거에요. 선택 인수(optional parameters)로 생각하면 돼요. 다음과 같이 호출하는 거죠.

[source]
----
(move-to character location
  :handle-chest mage-handle-chest
  :attack       mage-attack)
----

Eve: Keep in mind that if these functions are not provided we use default behavior: do nothing for handle-chest and run away from enemies in attack
이브: 이 함수들이 인수로 제공되지 않으면, `handle-chest`의 경우에는 아무런 동작을 하지 않고, ``attack``의 경우에는 적들로부터 도망치는 디폴트 동작을 하도록 정의했어요.

Pedro: Fine, but is this better than approach by subclassing? Seems that we have a lot of redundant information in move-to call.
페드로: 좋아요, 하지만 이것이 서브 클래싱보다 더 나은 접근법인가요? `move-to` 호출시 불필요한 정보를 많이 제공하는 것 같이 보이는데.

Eve: It's fixable, just define this call once, and give it alias
이브: 그 점은 개선될 수 있어요. 다음과 같이 하면 간결해져요.

[source]
----
(defn mage-move [character location]
  (move-to character location
    :handle-chest mage-handle-chest
    :attack       mage-attack))
----

Eve: Or use multimethods, it's even better.
이브: 멀티메소드를 사용하면 더 좋아요.

[source]
----
(defmulti move
  (fn [character location] (:class character)))

(defmethod move :mage [character location]
  (move-to character location
    :handle-chest mage-handle-chest
    :attack       mage-attack))
----

Pedro: I understand. But why do you think pass as argument is better than subclassing?
페드로: 이해했어요. 하지만 인수로 전달하는 것이 서브 클래싱크보다 왜 더 낫다는 거죠?

Eve: You can change behaviour dynamically. Assume your mage has no mana, so   instead of trying to cast fireballs, he can just teleport and run away, you just provide new function.
이브: 동작을 동적으로 변경할 수 있으니까요. 마법사가 에너지가 없다고 가정해 봐요. 그러면 불덩어리들을 던지는 대신에 공간 이동으로 도망칠 수 있어요. 단순히 새로운 함수를 제공하면 돼요.

Pedro: Makes sense. Functions everywhere.
페드로: 이제 이해가 됩니다. 함수만으로 모든 것이 해결 가능하네요.


== Episode 6. Iterator
== 에피소드 6. 반복자(Iterator) 패턴

[sidebar]
....
Technical consultant Kent Podiololis complains for C-style loops usage.

"Are we in 1980 or what?" -- Kent

기술 고문 켄트 포디올로리스(Kent Podiololis)가 C 스타일의 반복문 사용에 대해 불평한다.

"우리가 아직도 1980년대에 살고 있는 건가요?"  -- 켄트
....

Pedro: We definitely should use pattern Iterator from java.
패드로: 자바의 `Iterator` 인터페이스를 사용하면 돼요.

Eve: Don't be fool, nobody's using java.util.Iterator
이브: 놀리지 말아요. 아무도 ``java.util.Iterator``를 사용하고 있지 않아요.

Pedro: Everybody use it implicitly in for-each loop. It's a good way to traverse a container.
페드로: 모든 사람이 for-each 루프 구문에서 간접적으로 그것을 사용해요. 그것은 컨테이너를 순회(traverse)하는 좋은 방법이예요.

Eve: What does it mean "to traverse a container"?
이브: 컨테이너를 순회한다는 것이 무슨 의미죠?

Pedro: Formally, the container should provide two methods for you:
next() to return next element and hasNext() to return true if container has more elements.요
페드로: 컨테이너는 공식적으로 두 개의 메소드를 제공해야 해요. 즉,  ``next()`` 메소드는 다음 요소를 반환하고, ``hasNext()`` 메소드는 컨테이너가 더 많은 요소를 갖고 있으면 ``true``를 반환해야 하지요.

Eve: Ok. Do you know what linked list is?
이브: 좋아요. 그런데 혹시 연결 리스트(linked list)가 무엇인지 아시나요?

Pedro: Singly linked list?
페드로: 단일 연결 리스트(Singly linked list) 말씀하시는 건가요?

Eve: Singly linked list.
이브: 맞아요.

Pedro: Sure. It is a container consists of nodes. Each node has a data value and reference to th
e next node. And null value if there is no next node.
페드로: 물론이죠. 그것은 노드들로 구성된 컨테이너죠. 각 노드는 데이터 값과 다음 노드의 레퍼런스를 갖고 있어요. 다음 노드가 없으면 `null` 값을 갖게 되고요.

Eve: Correct. Now tell me how traversing such list is differ from traversing via iterator?
이브: 맞아요. 그럼 그런 리스트를 순회하는 것과, 반복자(iterator)를 통해 순회하는 것 사이에 차이가 있을까요?

Pedro: Emmm...
페드로: 음...

Pedro wrote two traversing snippets:
페드로는 순회하는 코드 두 개를 작성한다.

* Traversing using iterator
* 반복자를 통해 순회하기

[source,java]
----
Iterator i;
while (i.hasNext()) {
  i.next();
}
----

* Traversing using linked list
* 연결 리스트를 이용해 순히하기

[source,java]
----
Node next = root;
while (next != null) {
  next = next.next;
}
----

Pedro: They are pretty similar...What is analogue of Iterator in clojure?
페드로: 그러고 보니 둘이 아주 비슷하네요... 클로저에서는 반복자에 해당하는 것이 무엇인가요?

Eve: seq function.
이브: `seq` 함수입니다.

[source]
----
(seq [1 2 3])       => (1 2 3)
(seq (list 4 5 6))  => (4 5 6)
(seq #{7 8 9})      => (7 8 9)
(seq (int-array 3)) => (0 0 0)
(seq "abc")         => (\a \b \c)
----

Pedro: It returns a list...
페드로: 리스트를 반환하네요...

Eve: Sequence, because Iterator is just a sequence
이브: 정확히는 시퀀스예요. 반복자는 단순히 시퀀스이거든요.

Pedro: Is it possible to make seq works on custom datastructures?
페드로: 사용자 자료구조도 `seq` 함수의 인수로 들어갈 수 있나요?

Eve: Implement clojure.lang.Seqable interface
이브: `clojure.lang.Seqable` 인터페이스를 구현하면 가능해요.

[source]
----
(deftype RedGreenBlackTree [& elems]
  clojure.lang.Seqable
  (seq [self]
    ;; traverse element in needed order
    ))
----

Pedro: Fine then. But I've heard iterator is often used to achive laziness, for example to calculate value only during getNext() call, how list handle that?
페드로: 그렇다면 좋네요. 그런데 저는 시퀀스가 지연 평가될 수 있다고 들었어요. 예를 들면 ``getNext()``를 호출할 때에만 값을 계산하게 한다든지 하는 식으로요. 리스트로 어떻게 그것을 처리하나요?

Eve: List can be lazy as well, clojure calls such list "lazy sequence".
이브: 리스트는 지연 평가될 수 있어요. 클로저에서는 그런 리스트를 "지연 시퀀스"라고 불러요.

[source]
----
(def natural-numbers (iterate inc 1))
----

Eve: We defined thing to represent ALL natural numbers, but we haven't got OutOfMemory yet, because we haven't requested any value. It's lazy.
이브: 위의 정의로 모든 자연수를 표현할 수 있어요. 하지만 아무런 값도 아직 요청하고 있지 않아서, ``OutOfMemory``가 나지는 않아요.

Pedro: Could you explain more?
페드로: 조금 더 설명해 주실 수 있겠어요?

Eve: Unfortunately, I am too lazy for that.
이브: 유감스럽게도, 그러기에는 제가 너무 게으르네요(lazy).

Pedro: I will remember that!
페드로: 알겠습니다!


Episode 7: Memento
dpvlthem 7. 메멘토(Memento) 패턴

<상태>
User Chad Bogue lost the message he was writing for two days. Implement save button for him.

사용자 채드 보그(Chad Bogue)가 이틀 동안 작성했던 메시지를 날려 버렸다. 그를 위해 저장 버튼을 구현하라.
</상태>

Pedro: I don't believe there are people who can type in textbox for two days. Two. Days.
페드로: 이틀에 걸쳐 텍스트 박스에 타이핑할 수 있는 사람이 있다니 믿기지가 않네요. 이틀이라니!

Eve: Let's save him.
이브: 그를 구합시다.

Pedro: I googled this problem. Most popular approach to implement save button is Memento pattern. You need originator, caretaker and memento objects.
페드로: 이 문제로 구글 검색을 해 보니, 저장 버튼을 구현하는 가장 일반적인 접근법은 메펜토 패턴이네요. originator와 caretaker, memento 객체가 필요해요.

Eve: What's that?
이브: 그것이 다 뭐죠?

Pedro: Originator is just an object or state that we want to preserve. (text inside a textbox), caretaker is responsible to save state (save button) and memento is just an object to encapsulate state.
페즈로: originator는 저장하기 원하는 객체 또는 상태예요. 예를 들면, 텍스트 박스 안의 텍스트를 말해요. caretaker는 상태를 저장하는 일을 맡아요. 예를 들어, 저장 버튼이죠. 그리고 memento는 상태를 보관하는 객체이고요.

[source,java]
----
public class TextBox {
  // state for memento
  private String text = "";

  // state not handled by memento
  private int width = 100;
  private Color textColor = Color.BLACK;

  public void type(String s) {
    text += s;
  }

  public Memento save() {
    return new Memento(text);
  }

  public void restore(Memento m) {
    this.text = m.getText();
  }

  @Override
  public String toString() {
    return "[" + text + "]";
  }
}
----

Pedro: Memento is just an immutable object
페드로: memento는 불변 객체일 뿐이죠.

[source,java]
----
public final class Memento {
  private final String text;

  public Memento(String text) {
    this.text = text;
  }

  public String getText() {
    return text;
  }
}
----

Pedro: And caretaker is a demo
페드로: 그리고 다음의 코드가 caretaker 역할을 합니다.

[source,java]
----
// open browser, init empty textbox
TextBox textbox = new TextBox();

// type something into it
textbox.type("Dear, Madonna\n");
textbox.type("Let me tell you what ");

// press button save
Memento checkpoint1 = textbox.save();

// type again
textbox.type("song 'Like A Virgin' is about. ");
textbox.type("It's all about a girl...");

// suddenly browser crashed, restart it, reinit textbox
textbox = new TextBox();

// but it's empty! All work is gone!
// not really, you rollback to last checkpoint
textbox.restore(checkpoint1);
----

Pedro: Just a note if you want a multiple checkpoints, save memento's to the list.
페드로: 참고로, 여러 번 저장할 수 있도록 하려면 메멘토들을 리스트에 저장하면 되지요.

Eve: Originator, caretaker, memento - looks as a bunch of nouns, but actually it's all about two functions save and restore.
이브: originator, caretaker, memento - 필요한 게 너무 많네요. 하지만 실질적으로는 ``save``와 `restore` 함수만 있으면 충분해요.

[source]
----
(def textbox (atom {}))

(defn init-textbox []
 (reset! textbox {:text ""
                  :color :BLACK
                  :width 100}))

(def memento (atom nil))

(defn type-text [text]
  (swap! textbox
    (fn [m]
      (update-in m [:text] (fn [s] (str s text))))))

(defn save []
  (reset! memento (:text @textbox)))

(defn restore []
  (swap! textbox assoc :text @memento))
----

Eve: And demo as well.
이브: 그리고 다음은 실행 예고요.

[source]
----
(init-textbox)
(type-text "'Like A Virgin' ")
(type-text "it's not about this sensitive girl ")
(save)
(type-text "who meets nice fella")
;; crash
(init-textbox)
(restore)
----

Pedro: It's pretty the same code.
페드로: 거의 동일한 코드네요.

Eve: Yes, but you must care about memento immutability
이브: 그래요, 하지만 메멘토가 불변값이어야 한다는 것은 주의해야 해요.

Pedro: What does it mean?
페드로: 무슨 의미죠?

Eve: You are lucky, that you got String object in this example, String is immutable. But if you have something, that may change its internal state, you need to perform deep copy of this object for memento.
이브: 이 예제에서 자바 불변 `String` 객체를 다룬 것은 운이 좋은 경우예요. 하지만 내부 상태가 변할 수 있는 가변 객체를 다루는 경우에는, 메멘토 객체를 대상으로 깊은 복사(deep copuy)를 수행해 줄 필요가 있거든요.

Pedro: Oh, right. It's just a recursive clone() calls to obtain prototype.
페드로: 예, 맞아요. 프로토타입을 얻기 위해 재귀적으로 ``clone()``을 호출해 주어야 하죠.

Eve: We will talk about Prototype in a minute, but just remember that Memento is not about caretaker and originator, it is about save and restore.
이브: 프로토타입 패턴은 잠시 뒤에 이야기하겠지만, 메멘토 패턴은 저장(save)과 복원(restore)에 관련된 것이지, originator와 caretaker와 관련된 것은 아니라는 것을 기억해 두셔야 해요.


== Episode 8: Prototype
== 에피소드 8. 프로토타입(Prototype) 패턴

<상태>
Dex Ringeus detected that users feel uncomfortable with registration form. Make it more usable.

덱스 린지어스(Dex Ringeus)는 사용자들이 회원 등록 양식에 불편함을 느끼는 것을 발견했다. 이것을 좀 더 편리하게 만들어야 한다.
</상태>

Pedro: So, what's the problem with the registration?
페드로: 등록 양식에 무슨 문제가 있나요?

Eve: There are lot of fields users bored to type in.
이브: 사용자들이 입력할 항목들이 너무 많아서 짜증날 정도예요.

Pedro: For example?
페드로: 예를 들면요?

Eve: For example, weight. Having such field scares 90% of female users.
이브: 예를 들면 체중 항목이예요. 여성 사용자들의 90%가 그런 항목을 보면 짜증을 낼 거예요.

Pedro: But this field is important for our analytics system, we make food and clothes recomendations based on that field.
페드로: 하지만 이 항목은 우리의 분석 시스템에 중요해요. 이 항목 값에 근거해 음식과 옷을 추천해 주고 있거든요.

Eve: Then, make it optional, and if it is not provided, take some default value.
이브: 그러면 이 항목을 필수 입력 항목에서 제외하기로 하죠. 이 항목 값이 입력되지 않으면 기본값을 넣어 주고요.

Pedro: 60 kg is ok?
페드로: 60kg이면 적당할까요?

Eve: I think so.
디브: 그런 것 같아요.

Pedro: Ok, give me two minutes.
페드로: 알았어요. 2분만 기다려 주세요.

2 hours later
두 시간이 흐른 뒤

Pedro: I suggest to use some registration prototype which has all fields are filled with default values. After user completes the form we modify filled values.
페드로: 모든 항목이 기본값으로 채워진 등록 양식 프로토타입을 사용해요. 사용자가 양식 작성을 끝냈을 때, 기본값들을 변경하면 돼요.

Eve: Sounds great.
이브: 좋습니다.

Pedro: Here it is our standard registration form, with prototype in clone() method.
페드로: 여기에 표준 등록 양식이 있어요. `clone()` 메소드에서는 프로토타입을 사용하고 있고요.

[source,java]
----
public class RegistrationForm implements Cloneable {
  private String name = "Zed";
  private String email = "zzzed@gmail.com";
  private Date dateOfBirth = new Date(1970, 1, 1);
  private int weight = 60;
  private Gender gender = Gender.MALE;
  private Status status = Status.SINGLE;
  private List<Child> children = Arrays.asList(new Child(Gender.FEMALE));
  private double monthSalary = 1000;
  private List<Brand> favouriteBrands = Arrays.asList("Adidas", "GAP");
  // few hundreds more properties

  @Override
  protected RegistrationForm clone() throws CloneNotSupportedException {
    RegistrationForm prototyped = new RegistrationForm();
      prototyped.name = name;
      prototyped.email = email;
      prototyped.dateOfBirth = (Date)dateOfBirth.clone();
      prototyped.weight = weight;
      prototyped.status = status;
      List<Child> childrenCopy = new ArrayList<Child>();
      for (Child c : children) {
        childrenCopy.add(c.clone());
      }
      prototyped.children = childrenCopy;
      prototyped.monthSalary = monthSalary;
      List<String> brandsCopy = new ArrayList<String>();
      for (String s : favouriteBrands) {
        brandsCopy.add(s);
      }
      prototyped.favouriteBrands = brandsCopy;
    return  prototyped;
  }
}
----

Pedro: Every time we create a user, call clone() and then override needed properties.
페드로: 사용자를 만들 때마다, ``clone()``을 호출해서 기본값을 바꿉니다.

Eve: Awful! In mutable world clone() is needed to create new object with the same properties. The hard part is the copy must be deep, i.e. instead of copying reference you need recursively clone() other objects, and what if one of them doesn't have clone()...
이브: 끔직하네요! 가변 자료형의 세상에서는 동일한 값의 객체를 새로 생성하려면 ``clone()``이 필요해요. 난점은 깊은 복사를 해야 한다는 것입니다. 단순히 레퍼런스를 복사하면 안되고, 재귀적으로 내부의 객체들을 clone() 해야만 하지요. 그런데 그 객체들 중의 일부에 clone() 메소드가 없으면 어떻게 될까요?

Pedro: That's the problem and this pattern solves it.
페드로: 그게 바로 문제인데, 이 패턴은 그 문제를 해결해 주죠.

Eve: I don't think it is a solution if you need to implement clone every time you adding new object.
이브: 제가 보기에, 새로운 객체를 추가해 줄 때마다 `clone` 메소드를 구현해 주어야만 한다면, 그것은 제대로 된 해결책이라고 보기 힘들다고 생각해요.

Pedro: How clojure avoid this?
페드로: 클로저로는 이런 문제를 어떻게 피할 수 있죠?

Eve: Clojure has immutable data structures. That's all.
이브: 클로저는 불변 자료구조를 제공해요. 그것이 전부예요.

Pedro: How does it solve prototype problem?
페드로: 불변 자료구조로 프로토타입 문제를 어떻게 해결한다는 거죠?

Eve: Every time you modify object, you get a fresh new immutable copy of your data, and old one is not changed. Prototype is not needed in immutable world
이브: 객체를 변경할 때마다, 새로운 불변 객체를 얻게 되요. 그래서 예전 객체는 변경되지 않지요. 불변 자료형의 세상에서는 프로토타입 패턴이 필요 없어요.

[source]
----
(def registration-prototype
     {:name          "Zed"
      :email         "zzzed@gmail.com"
      :date-of-birth "1970-01-01"
      :weight        60
      :gender        :male
      :status        :single
      :children      [{:gender :female}]
      :month-salary  1000
      :brands        ["Adidas" "GAP"]})

;; return new object
(assoc registration-prototype
     :name "Mia Vallace"
     :email "tomato@gmail.com"
     :weight 52
     :gender :female
     :month-salary 0)
----

Pedro: Great! But how this affects performance?
Copying million rows each time you adding new value seems time consuming operation.
페드로: 훌륭하네요! 하지만 그런 식으로는 성능에 영향을 미치지 않을까요? 새로운 값을 추가할 때마다 수백만 개의 데이터를 복사하려면 꽤 시간이 걸리지 않나요?

Eve: No, it is not. Go to Google and search for persistent data structures and structural sharing
이브: 아니, 그렇지 않아요. 구글에 가서 존속 데이터 구조(persistent data structures)와 구조 공유(structural sharing)에 관해 검색해 보세요.

Pedro: Thanks a lot.
페드로: 고마워요.


== Episode 9: Mediator
== 에피소드 9. 중개자(Mediator) 패턴

[sidebar]
....
Recently performed external code review shows a lot of issues with current codebase. Veerco Wierde emphasizes tight coupling in chat application.

외부 인사가 최근에 코드를 검토한 결과, 현재의 코드에 문제가 많다고 한다. 특히 비어코 위어드(Veerco Wierde)씨는 채팅 애플리케이션에서의 강한 결합(tight coupling)을 지적하고 있다.
....

Eve: What is tight coupling?
이브: 강한 결합이 뭐죠?

Pedro: It's the problem when objects know too much about each other.
페드로: 한 객체가 다른 객체에 대해 너무 많은 것을 알고 있을 때 나타나는 문제예요.

Eve: Could you be more specific?
이브: 좀더 구체적으로 설명해 주실 수 있겠어요?

Pedro: Look at the current chat implementation
페드로: 현재의 채팅 프로그램 소스를 보시죠.

[source,java]
----
public class User {
  private String name;
  List<User> users = new ArrayList<User>();

  public User(String name) {
    this.name = name;
  }

  public void addUser(User u) {
    users.add(u);
  }

  void sendMessage(String message) {
    String text = String.format("%s: %s\n", name, message);
    for (User u : users) {
      u.receive(text);
    }
  }

  private void receive(String message) {
    // process message
  }
}
----

Pedro: The problem here is the user knows everything about other users. It is very hard to use and maintain such code. When new user connects to the chat, you must add a reference to him via addUser for every existing user.
페드로: 여기서의 문제는 사용자가 모든 다른 사용자들에 관한 정보를 갖고 있다는 것이죠. 이런 코드를 사용하고 유지/보수 하는 것은 대단히 어렵죠. 새로운 사용자가 이 채팅에 들어올 때마다, 모든 사용자가 `addUser` 메소드를 통해 그 사용자에 대한 레퍼런스를 추가해야만 하거든요.

Eve: So, we just move one piece of responsibility to another class?
이브: 그러면 그 일에 해당하는 부분을 다른 클래스로 옮기면 되지 않나요?

Pedro: Yes, kind of. We create mega-aware class, called mediator, that binds all parts together. Obviously, each part knows only about mediator.
페드로: 어느 정도는 맞아요. 모든 사용자들을 관리하는 중개자(mediator)라고 불리는 클래스를 만들면 돼요. 각 사용자는 이 중개자 객체만을 내부에 담게 되죠.

[source,java]
----
public class User {
  String name;
  private Mediator m;

  public User(String name, Mediator m) {
    this.name = name;
    this.m = m;
  }

  public void sendMessage(String text) {
    m.sendMessage(this, text);
  }

  public void receive(String text) {
    // process message
  }
}

public class Mediator {

  List<User> users = new ArrayList<User>();

  public void addUser(User u) {
    users.add(u);
  }

  public void sendMessage(User u, String text) {
    for (User user : users) {
      u.receive(text);
    }
  }
}
----

Eve: That seems like a simple refactoring problem.
이브: 이것은 단순한 리팩토링 문제같이 보이는 데요.

Pedro: Profit may be underestimated, but if you have hundreds of mutually connected components (UI for example) mediator is really a savior.
페드로: 그럴 수도 있지만, 예를 들어, Ui에서 서로 결합된 수백개의 부품들(components)이 있는 경우에는 이 중개자 패턴이 구세주 역할을 할 수 있어요.

Eve: Agreed.
이브: 인정합니다.

Pedro: Now the clojure turn.
페드로: 클로저에서는 이런 경우 어떻게 처리하죠?

Eve: Ok...let's look...your mediator is responsible for saving users and sending messages
이브: 음... 보아 하니... 중개자라는 것이 하는 일이 사용자들을 저장하고 메시지를 보내는 것이네요.

[source]
----
(def mediator
  (atom {:users []
         :send (fn [users text]
                 (map #(receive % text) users))}))

(defn add-user [u]
  (swap! mediator
         (fn [m]
           (update-in m [:users] conj u))))

(defn send-message [u text]
  (let [send-fn (:send @mediator)
        users (:users @mediator)]
    (send-fn users (format "%s: %s\n" (:name u) text))))

(add-user {:name "Mister White"})
(add-user {:name "Mister Pink"})
(send-message {:name "Joe"} "Toby?")
----

Pedro: Good enough.
페드로: 아주 좋네요.

Eve: Nothing interesing here, because it is just a one approach to reduce coupling.
이브: 여기에 특별한 것은 없어요. 단지 결합도를 줄이는 방법 중의 하나일 뿐이니까요.


== Episode 10: Observer
== 에피소드: 관찰자(Observer) 패턴

[sidebar]
....
Independent security commision detected hacker Dartee Hebl has over a billion dollars balance on his account. Track big transactions to the accounts.

독립 보안 위원회가 해커 다티 헤블(Dartee Hebl)이 그의 계좌에 십억 달러의 잔고를 가지고 있는 것을 포착했다. 그래서 연관 계좌들과의 거래 내역을 추적해야 한다.
....

Pedro: Are we Holmses?
페즈로: 우리가 셜럭 홈즈가 되는 건가요?

Eve: No, but there is a lack of logging in the system, need to find a way to track all changes to balance.
이브: 그런 건 아니지만, 지금 시스템에는 로깅 기능이 없어서, 모든 잔고 변화를 추적할 방법을 찾아야 해요.

Pedro: We could add observers. Every time we modify balance, if change is big enough, notify about this and track the reason. We need Observer interface.
페드로: 관찰자들을 추가하면 돼요. 잔고의 변화가 큰 경우에만, 이 사실을 통지하고 그 이유를 추적하면 되죠. 먼저 `Observer` 인터페이스를 다음과 같이 정의합니다.

[source,java]
----
public interface Observer {
  void notify(User u);
}
----

Pedro: And two specific observers
페드로: 그리고 이 인터페이스를 구현하는 관찰자 클래스 두 개를 정의합니다.

[source,java]
----
class MailObserver implements Observer {
  @Override
  public void notify(User user) {
    MailService.sendToFBI(user);
  }
}

class BlockObserver implements Observer {
  @Override
  public void notify(User u) {
    DB.blockUser(u);
  }
}
----

Pedro: Tracker class would be responsible for managing observers.
페드로: `Tracker` 클래스에서 이 관찰자 객체들을 관리합니다.

[source,java]
----
public class Tracker {
  private Set<Observer> observers = new HashSet<Observer>();

  public void add(Observer o) {
    observers.add(o);
  }

  public void update(User u) {
    for (Observer o : observers) {
      o.notify(u);
    }
  }
}
----

Pedro: And the last part: init tracker with the user and modify its addMoney method. If transcation amount is greaterthan 100$, notify FBI and block this user.
페드로: 그리고 마지막으로 `User` 객체를 생성할 때 `initTracker()` 메소드를 호출해 이 두 관찰자 객체를 추가합니다. 그리고 `addMoney` 메소드에서 만약 거래액이 100$를 넘으면 FBI에 통지하고 이 사용자의 거래를 차단하도록 수정해 줍니다.

[source,java]
----
public class User {
  String name;
  double balance;
  Tracker tracker;

  public User() {
    initTracker();
  }

  private void initTracker() {
    tracker = new Tracker();
    tracker.add(new MailObserver());
    tracker.add(new BlockObserver());
  }

  public void addMoney(double amount) {
    balance += amount;
    if (amount > 100) {
      tracker.update(this);
    }
  }
}
----

Eve: Why are you created two separate observers? You could use it in a one.
이브: 왜 관찰자를 따로 두 개 만들었나요? 다음처럼 한 개만 만들어도 될 것 같은 데요.

[source,java]
----
class MailAndBlock implements Observer {
  @Override
  public void notify(User u) {
    MailService.sendToFBI(u);
    DB.blockUser(u);
  }
}
----

Pedro: Single responsibility principle.
페드로: 단일 책임 윈칙(Single responsibility principle)을 따른 거죠.

Eve: Oh, yeah.
디브: 아, 그렇군요.

Pedro: And you can compose observer functionality dynamically.
페드로: 그러면 관찰자 기능을 동적으로 결합할 수 있게 되거든요.

Eve: I see your point.
이브: 예, 알겠어요.

[source]
----
;; Tracker

(def observers (atom #{}))

(defn add [observer]
  (swap! observers conj observer))

(defn notify [user]
  (map #(apply % user) @observers))

;; Fill Observers

(add (fn [u] (mail-service/send-to-fbi u)))
(add (fn [u] (db/block-user u)))

;; User

(defn add-money [user amount]
  (swap! user
    (fn [m]
      (update-in m [:balance] + amount)))
  ;; tracking
  (if (> amount 100) (notify)))
----

Pedro: It's a pretty the same way?
페드로: 거의 같은 방식이네요?

Eve: Yeah, in fact observer is just a way to register function, which will be called after another function.
이브: 그래요, 사실 관찰자는 함수를 등록하는 한 가지 방법일 뿐이거든요. 그리고 나서 다른 함수가 그 등록된 함수를 호출하는 거죠.

Pedro: It is still the pattern.
페드로: 이것도 여전히 패턴이네요.

Eve Sure, but we can improve solution a bit using clojure watches.
이브: 물론이죠, 하지만 다음처럼 클로저의 watch 기능을 이용하면 위의 코드를 더 개선할 수 있어요.

[source]
----
(add-watch
  user
  :money-tracker
  (fn [k r os ns]
    (if (< 100 (- (:balance ns) (:balance os)))
      (notify))))
----

Pedro: Why is that better?
페드로: 왜 이 방식이 더 나은 거죠?

Eve: First of all, our add-money function is clean, it just adds money. Also, watcher tracks every change to the state, not the ones we handle in mutator functions, like add-money
이브: 우선 `add-money` 함수가 더 깔끔해졌어요. 단순히 돈을 더하는 일만 하고 있죠. 그리고 watcher는 ``add-money`` 함수에서의 변경 내용뿐만 아니라, user에게 일어나는 모든 상태 변화를 추적할 수 있어요.

Pedro: Explain please.
페드로: 좀 더 설명해 주세요.

Eve: If there is provided another secred method secret-add-money for changing balance, watchers will handle that as well.
이브: 만약 또 다른 함수 `secret-add-money`가 잔고를 바꾼다 하더라도, watcher는 그것도 처리할 수 있어요.

Pedro: That's awesome!
페드로: 오! 멋지네요.


== Episode 11: Interpreter
== 에피소드 11. 해석자(Interpreter) 패턴

[sidebar]
....
Bertie Prayc stole important data from our server and shared it via BitTorrent system. Create a fake account for Bertie to discredit him.

버티 프레이시(Bertie Prayc)가 우리 서버에서 중요한 데이터를 훔쳐서 비트토렌트(BitTorrent) 시스템을 통해 공유하고 있다. 버티의 가짜 계정을 만들어 그의 평판을 떨어뜨려야 한다.
....

Pedro: BitTorrent system based on .torrent files. We need to write Bencode encoder.
페드로: 비트토렌트 시스템은 .torrent 파일에 기반하고 있어서 Bencode 인코더를 만들어야 해요.

Eve: Yes, but first let's agree on the format spec
이브: 네, 그렇다면 먼저 Bencode 포맷에 대해 알아야겠네요.

Bencode encoding rules:
다음은 Bencode 인코딩 규칙이다.

* Two datatypes are supported:
** Integer N is encoded as i<N>e. (42 = i42e)
** String S is encoded as <length>:<contents> (hello = 5:hello)

* Two containers are supported:
** List of values is encoded as l<contents>e ([1, "Bye"] = li1e3:Byee)
** Map of values is encoded as d<contents>e ({"R" 2, "D" 2} = d1:Ri2e1:Di2ee)
***Keys are just strings, Values are any bencode element

* 2개의 데이터 타입이 지원된다.
** 정수 N은 ``i<N>e``로 인코딩된다. (예) 42 = i42e
** 문자열 S는 ``<length>:<contents>``로 인코딩된다. (예) hello = 5:hello

* 2개의 컨데이너가 지원된다.
** 리스트는 ``l<contents>e``로 인코딩된다. (예) [1, "Bye"] = li1e3:Byee
** 맵은 ``d<contents>e``로 인코딩된다. (예) {"R" 2, "D" 2} = d1:Ri2e1:Di2ee
*** 키는 단순히 문자열이고, 값에는 모든 Bencode 요소가 허용된다.

Pedro: Seems easy.
페드로: 쉬워 보이네요.

Eve: Maybe, but take into account that values may be nested, list inside list, etc.
이브: 그럴 수도 있지만, 값들은 중첩될 수 있다는 점을 고려해야 해요. 예를 들면 리스트 안의 리스트 같은.

Pedro: Sure. I think we can use Interpreter pattern for bencode encoding.
페드로: 물론이죠. bencode 인코딩에는 해석자 패턴을 사용할 수 있을 것 같네요.

Eve: Try it.
이브: 한번 해 보시죠.

Pedro: We start from interface for all bencode elements
페드로: 모든 bencode 요소들을 위한 인터페이스부터 시작해 보죠.

[source,java]
----
interface BencodeElement {
  String interpret();
}
----

Pedro: Then we provide implementation for each datatype and datacontainer
페드로: 그리고 나서 각각의 데이터 타입과 데이터 컨데이너에서 위의 인터페이스를 구현합니다.

[source,java]
----
class IntegerElement implements BencodeElement {
  private int value;

  public IntegerElement(int value) {
    this.value = value;
  }

  @Override
  public String interpret() {
    return "i" + value + "e";
  }
}

class StringElement implements BencodeElement {
  private String value;

  StringElement(String value) {
    this.value = value;
  }

  @Override
  public String interpret() {
    return value.length() + ":" + value;
  }
}

class ListElement implements BencodeElement {
  private List<? extends BencodeElement> list;

  ListElement(List<? extends BencodeElement> list) {
    this.list = list;
  }

  @Override
  public String interpret() {
    String content = "";
    for (BencodeElement e : list) {
      content += e.interpret();
    }
    return "l" + content + "e";
  }
}

class DictionaryElement implements BencodeElement {
  private Map<StringElement, BencodeElement> map;

  DictionaryElement(Map<StringElement, BencodeElement> map) {
    this.map = map;
  }

  @Override
  public String interpret() {
    String content = "";
    for (Map.Entry<StringElement, BencodeElement> kv : map.entrySet()) {
      content += kv.getKey().interpret() + kv.getValue().interpret();
    }
    return "d" + content + "e";
  }
}
----

Pedro: And finally, our bencoded string can be constructed from common datastructures programmatically
페드로: 마지막으로 bencode 인코딩 문자열을 만들 수 있어요.

[source,java]
----
// discredit user
Map<StringElement, BencodeElement> mainStructure = new HashMap<StringElement, BencodeElement>();
// our victim
mainStructure.put(new StringElement("user"), new StringElement("Bertie"));
// just downloads files
mainStructure.put(new StringElement("number_of_downloaded_torrents"), new IntegerElement(623));
// and nothing uploads
mainStructure.put(new StringElement("number_of_uploaded_torrents"), new IntegerElement(0));
// and nothing donates
mainStructure.put(new StringElement("donation_in_dollars"), new IntegerElement(0));
// prefer dirty categories
mainStructure.put(new StringElement("preffered_categories"),
                      new ListElement(Arrays.asList(
                          new StringElement("porn"),
                          new StringElement("murder"),
                          new StringElement("scala"),
                          new StringElement("pokemons")
                      )));
BencodeElement top = new DictionaryElement(mainStructure);

// let's totally discredit him
String bencodedString = top.interpret();
BitTorrent.send(bencodedString);
----

Eve: Interesting, but that is ton of code!
이브: 재미있네요, 그런데 코드량이 너무 많네요!

Pedro: We pay readability for capabilities.
페드로: 기능이 많다 보니 읽기 어려워졌어요.

Eve: I suppose you've heard concept Code is Data, that's a lot easier in clojure
이브: 코드가 곧 데이터(Code is Data)라는 말을 들어 보신 적 있을 거예요. 그래서 클로저에서는 훨씬 수월해지죠.

[source]
----
;; multimethod to handle bencode structure
(defmulti interpret class)

;; implementation of bencode handler for each type
(defmethod interpret java.lang.Long [n]
  (str "i" n "e"))

(defmethod interpret java.lang.String [s]
  (str (count s) ":" s))

(defmethod interpret clojure.lang.PersistentVector [v]
  (str "l"
       (apply str (map interpret v))
       "e"))

(defmethod interpret clojure.lang.PersistentArrayMap [m]
  (str "d"
       (apply str (map (fn [[k v]]
                         (str (interpret k)
                              (interpret v))) m))
       "e"))

;; usage
(interpret {"user" "Bertie"
            "number_of_downloaded_torrents" 623
            "number_of_uploaded_torrent" 0
            "donation_in_dollars" 0
            "preffered_categories" ["porn"
                                    "murder"
                                    "scala"
                                    "pokemons"]})
----

Eve: You see how it is much easier define specific data?
이브: 데이터를 정의하는 것이 얼마나 쉬운지 보이세요?

Pedro: Sure, and interpret it's just a function per bencode type, instead of separate class.
페드로: 그러네요.``interpret``은 bencode 자료형 당 단순히 하나의 함수네요. 별도의 클래스가 아니라.

Eve: Correct, interpreter is nothing but a set of functions to process a tree.
이브: 맞아요, 해석자 패턴은 단순히 트리를 처리하는 함수들일 뿐인거죠.


== Episode 12: Flyweight
== 에피소드 12. 플라이웨이트(Flyweight) 패턴

[sidebar]
....
Administrators of the lawyer firm Cristopher, Matton & Pharts detected that reporting system consumes a lot of memory and garbage collector continiously hangs system for seconds. Fix that.
한 법무 법인의 시스템 관리자 크리스토펴 매튼 & 파트(Cristopher, Matton & Pharts)는 보고 시스템이 메모리를 많이 소모해서 가비지 컬렉터가 끊임없이 시스템을 몇 초 동안 멈추게 한다는 것을 발견했다. 그것을 고쳐야 한다.
....

Pedro: I've seen this issue before.
페드로: 저도 전에 이런 문제를 본 적이 있어요.

Eve: What's wrong?
이브: 무엇이 잘못된 거죠?

Pedro: They have realtime charts with a lot of different points. It's a huge amount of memory. As a result garbage collector stops the system.
페드로: 많은 점(point) 데이터를 사용하는 실시간 차트 프로그램 때문이예요. 메모리를 많이 소모하거든요. 그래서 가비지 컬렉터가 시스템을 멈추게 하는 거고요.

Eve: Hmmm, what we can do?
이브: 음, 그럼 무엇을 해야 하죠?

Pedro: Not much, caching does not help us because points are...
페드로: 달리 할 수 있는 일이 별로 없어요. 캐싱도 별 도움이 안되고...

Eve: Wait!
이브:잠깐만요!

Pedro: What?
페드로: 무슨 일이죠?

Eve: They use age values for points, why not precompute these points for most common ages? Say for age [0, 100]
이브: 점들은 나이 데이터로 이루어져 있네요. 일반적인 나이(예를 들면, 나이 [0, 100])의 경우, 왜 미리 계산해 놓지 않는 거죠?

Pedro: You mean use Flyweight pattern?
페드로: 플라이웨이트 패턴을 사용하라는 말씀인가요?

Eve: I mean reuse objects.
이브: 제 말은 객체를 재사용하자는 겁니다.

[source,java]
----
class Point {
  int x;
  int y;

  /* some other properties*/

  // precompute 10000 point values at class loading time
  private static Point[][] CACHED;
  static {
    CACHED = new Point[100][];
    for (int i = 0; i < 100; i++) {
      CACHED[i] = new Point[100];
      for (int j = 0; j < 100; j++) {
        CACHED[i][j] = new Point(i, j);
      }
    }
  }

  Point(int x, int y) {
    this.x = x;
    this.y = y;
  }

  static Point makePoint(int x, int y) {
    if (x >= 0 && x < 100 &&
        y >= 0 && y < 100) {
      return CACHED[x][y];
    } else {
      return new Point(x, y);
    }
  }
}
----

Pedro: For this pattern we need two things: precompute most used points at a startup time, and use static factory method instead of constructor to return cached object.
페드로: 이 패턴의 경우에는 두 가지가 필요해요. 프로그램 시작 시점에 대부분의 점 데이터를 미리 계산하는 것과, 생성자 대신에 정적 팩토리 메소드를 이용해서 캐쉬된 객체를 반환하는 것이죠.

Eve: Have you tested it?
이브: 테스트해 보았나요?

Pedro: Sure, the system works like a clock.
페드로: 물론이죠. 시스템은 아주 정확히 동작했습니다.

Eve: Excellent, here is my version
이브: 좋아요, 다음은 클로저 버전이예요.

[source]
----
(defn make-point [x y]
  [x y {:some "Important Properties"}])

(def CACHE
  (let [cache-keys (for [i (range 100) j (range 100)] [i j])]
      (zipmap cache-keys (map #(apply make-point %) cache-keys))))

(defn make-point-cached [x y]
  (let [result (get CACHE [x y])]
    (if result
      result
      (make-point x y))))
----

Eve: It creates a flat map with pair [x, y] as a key, instead of two-dimensional array.
이브: 이차원 배열 대신에, [x y] 좌표를 키로 갖는 일차원 맵을 만듭니다.

Pedro: Pretty the same.
페드로: 자바의 경우와 마찬가지네요.

Eve: No, it is much flexible, you can't use two-dimensional array if you need to cache three points or non-integer values.
이브; 아니예요, 훨씬 더 유연해요. 세 개의 점이나 정수가 아닌 값을 캐시해야 할 필요가 있을 때에는 이차원 배열을 사용할 수 없으니까요.

Pedro: Oh, got it.
페드로: 아, 이해했어요.

Eve: Even better, in clojure you can just use memoize function to cache calls to factory function make-point
이브: 더 좋은 것은, 클로저에서는 `memoize` 함수를 이용하면 팩토리 함수 ``make-point``를 호출한 결과를 캐싱할 수 있어요.

[source]
----
(def make-point-memoize (memoize make-point))
----

Eve: Every call (except first one) with the same parameters return cached value.
이브: 그래서 최초의 호출할 때를 제외하고는, 같은 인자를 사용해 함수를 호출하게 되면 캐시에 저장된 값을 반환해요.

Pedro: That's awesome!
페드로: 그것 참 멋진 기능이네요!

Eve: Of course, but remember if your function has side-effects, memoization is bad idea.
이브: 물론이죠. 하지만, 부수 효과(side effects)를 가진 함수인 경우에는 memoize 기능을 사용하지 않는 것이 좋다는 점도 기억해 두세요.

=== Episode 13: Builder
=== 에피소드 13: 빌더(Builder) 패턴

[sidebar]
....
Tuck Brass complains that his old automatic coffee-making system is very slow in usage. Customers can't wait long enough and going away.
턱 브라스(Tuck Brass)는 자동 커피 메이커 시스템이 오래돼서 너무 느리다고 불평한다. 고객들은 기다리지 못해 그냥 가버린다.
....

Pedro: Need to understand what's the problem exactly?
페드로: 무엇이 문제인지 정확히 이해할 필요가 있지 않나요?

Eve: I've researched, system is old, written in COBOL and built around expert system question-answer. They were very popular long time ago.
이브: 연구해 봤는데, 시스템이 낡았고요, 코볼로 작성된 질의-응답 전문가 시스템으로 구축되어 있어요. 그것은 예전에는 아주 인기가 있었죠.

Pedro: What do you mean by "question-answer"
페드로: "질의-응답"이 무슨 말이에요?

Eve: There is operator in front of terminal. System asks: "Do yo want to add water?", operator answers "Yes". Then system asks again: "Do you want to add coffee", operator answers "Yes" and so forth.
이브: 터미널 앞에 사람이 있어요. 시스템이 "물을 추가할까요?" 라고 물으면, 사람이 "네"라고 답해요. 그러면 시스템이 다시 "커피를 추가할까요?" 라고 물으면, 사람이 "네"라고 답하죠. 뭐 이런 식이죠.

Pedro: It's a nightmare, I just want coffee with milk. Why they don't use predefined options: coffee with milk, coffee with sugar and so on.
페드로: 악몽이로군요, 난 단지 밀크 커피를 원할 뿐인데요. 왜 미리 준비된 커피를 사용하지 않죠: 밀크 커피, 설탕 커피 등등.

Eve: Because it is the raisin of the system: customer can make coffee with any set of ingridients by themselves
이브: 컴퓨터가 재료를 혼합해서 모든 커피를 만들 수 있기를 원했던 거죠.

Pedro: Okay, let's fix it with Builder pattern.
페드로: 오케이, 알겠어요. 빌더 패턴으로 고쳐봅시다.

[source, java]
....
public class Coffee {
  private String coffeeName; // required
  private double amountOfCoffee; // required
  private double water; // required
  private double milk; // optional
  private double sugar; // optional
  private double cinnamon; // optional

  private Coffee() { }

  public static class Builder {
    private String builderCoffeeName;
    private double builderAmountOfCoffee; // required
    private double builderWater; // required
    private double builderMilk; // optional
    private double builderSugar; // optional
    private double builderCinnamon; // optional

    public Builder() { }

    public Builder setCoffeeName(String name) {
      this.builderCoffeeName = name;
      return this;
    }

    public Builder setCoffee(double coffee) {
      this.builderAmountOfCoffee = coffee;
      return this;
    }

    public Builder setWater(double water) {
      this.builderWater = water;
      return this;
    }

    public Builder setMilk(double milk) {
      this.builderMilk = milk;
      return this;
    }

    public Builder setSugar(double sugar) {
      this.builderSugar = sugar;
      return this;
    }

    public Builder setCinnamon(double cinnamon) {
      this.builderCinnamon = cinnamon;
      return this;
    }

    public Coffee make() {
      Coffee c = new Coffee();
        c.coffeeName = builderCoffeeName;
        c.amountOfCoffee = builderAmountOfCoffee;
        c.water = builderWater;
        c.milk = builderMilk;
        c.sugar = builderSugar;
        c.cinnamon = builderCinnamon;

      // check required parameters and invariants
      if (c.coffeeName == null || c.coffeeName.equals("") ||
          c.amountOfCoffee <= 0 || c.water <= 0) {
        throw new IllegalArgumentException("Provide required parameters");
      }

      return c;
    }
  }
}
....

Pedro: As you see, you can't instantiate Coffee class easily, you need to set parameters with nested Builder class
페드로: 보다시피, 커피 클래스의 인스턴스를 만드는 것이 쉽지 않아요. 내포된 Builder 클래스로 파라미터를 설정할 필요가 있죠.

[source, java]
....
Coffee c = new Coffee.Builder()
        .setCoffeeName("Royale Coffee")
        .setCoffee(15)
        .setWater(100)
        .setMilk(10)
        .setCinnamon(3)
        .make();
....

Pedro: Calling to method make checks all required parameters, and could validate and throw an exception if object is in inconsistent state.
페드로: 메소드를 호출하면 모든 필수 파라미터를 검사를 하는데, 검사하다가 객체의 상태에 뭔가 문제가 있으면 예외를 던지죠.

Eve: Awesome functionality, but why so verbose?
이브: 멋진 기능이긴 한데, 상당히 장황하네요.

Pedro: Beat it.
페드로: 클로저로 한 번 해보시죠.

Eve: A piece of cake, clojure supports optional arguments, everything what builder pattern is about.
이브: 식은 죽 먹기죠, 클로저는 선택 파라미터를 제공하는데, 그게 빌더 패턴을 대신할 수 있어요.

[source, clojure]
....
(defn make-coffee [name amount water
                   & {:keys [milk sugar cinnamon]
                      :or {milk 0 sugar 0 cinnamon 0}}]
  ;; definition goes here
  )

(make-coffee "Royale Coffee" 15 100
             :milk 10
             :cinnamon 3)
....

Pedro: Aha, you have three required parameters and three optionals, but required parameters still without names.
페드로: 아하, 파라미터 3개는 필수이고 나머지는 선택 파라미터들이긴 한데, 필수 파라미터에는 이름이 없군요.

Eve: What do you mean?
이브: 무슨 말이죠?

Pedro: From the client call I see number 15 but I have no idea what it might be.
페드로: 함수 호출할 때 숫자 15를 넘기는데, 그게 무엇을 의미하는지 전혀 모르쟎아요.

Eve: Agreed. Then, let's make all parameters are named and add precondition for required, the same way you do with the builder.
이브: 맞네요. 그러면 모든 파라미터에 이름을 짓고, 사전 조건(precondition)을 걸어 보죠. 그럼 당신이 한 것과 똑같죠.

[source, clojure]
....
(defn make-coffee
  [& {:keys [name amount water milk sugar cinnamon]
      :or {name "" amount 0 water 0 milk 0 sugar 0 cinnamon 0}}]
  {:pre [(not (empty? name))
         (> amount 0)
         (> water 0)]}
  ;; definition goes here
  )

(make-coffee :name "Royale Coffee"
             :amount 15
             :water 100
             :milk 10
             :cinnamon 3)
....

Eve: As you see all parameters are named and all required params are checked in :pre constraint. If constraints are violated AssertionError is thrown.
이브: 보다시피 모든 파라미터에 이름이 있고, 필수 파라미터는 :pre 조건을 주어 검사되고 있죠. 조건이 위반되면 AssertionError가 발생하죠.

Pedro: Interesting, :pre is a part of a language?
페드로: 재밌네요. :pre는 언어의 일부인가요?

Eve: Sure, it's just a simple assertion. There is also :post constraint, with the similar effect.
이브: 그렇죠. 단지 간단한 어써션(assertion)이에요. :post 조건도 있는데, 비슷해요.

Pedro: Hm, okay. But as you know Builder pattern often used as a mutable datastucture, StringBuilder for example.
페드로: 흠, 오케이. 하지만 알다시피 빌더 패턴은 가변 자료구조에 자주 사용되죠. 예를 들어, StringBuilder가 있어요.

Eve: It's not a part of clojure philosophy to use mutables, but if you really want, no problem. Just create a new class with deftype and do not forget to use volatile-mutable on the properties you want to mutate.
이브: 가변 데이타를 사용하는 것은 클로저의 철학과는 맞지 않지만, 굳이 가변 데이타를 사용해야 한다해도, 문제는 없어요. deftype으로 클래스를 만든 다음, 변경하려는 속성에 일시적 가변 변수를 사용하면 돼요.

Pedro: Where is the code?
페드로: 코드를 보여주시죠.

Eve: Here is example of custom implementation of mutable StringBuilder in clojure. It has a lot of drawbacks and limitations but you've got the idea.
이브: 가변 StringBuilder를 클로저로 구현한 예제가 여기 있어요. 단점도 있고 제한적이지만, 아이디어를 얻을 수 있어요.

[source, clojure]
....
;; interface
(defprotocol IStringBuilder
  (append [this s])
  (to-string [this]))

;; implementation
(deftype ClojureStringBuilder [charray ^:volatile-mutable last-pos]
  IStringBuilder
  (append [this s]
    (let [cs (char-array s)]
      (doseq [i (range (count cs))]
        (aset charray (+ last-pos i) (aget cs i))))
    (set! last-pos (+ last-pos (count s))))
  (to-string [this] (apply str (take last-pos charray))))

;; clojure binding
(defn new-string-builder []
  (ClojureStringBuilder. (char-array 100) 0))

;; usage
(def sb (new-string-builder))
(append sb "Toby Wong")
(to-string sb) => "Toby Wong"
(append sb " ")
(append sb "Toby Chung") => "Toby Wang Toby Chung"
....

Pedro: Not as hard as I thought.
페드로: 생각만큼 어렵지는 않네요.

== Episode 14: Facade
== 에피소드 14: 파사드(Facade) 패턴

Our new member Eugenio Reinn Jr. commited file with diff in 134 lines to processing servlet. But actual work is just to process request. All other code injection and imports. It MUST be one line commit.
[sidebar]
....
새로운 멤버 유진 라인 주니어(Eugenio Reinn Jr.)가 처리 중인 서블릿에 134개 라인이 추가된 파일을 커밋했다. 하지만 추가된 코드들이 실제로 하는 일은 요청을 처리하는 것 뿐이었다. 즉 클래스들을 임포트해서 사용한 것이 전부이다. 이것은 한 줄짜리 커밋이어야 했다.
....

Pedro: Who cares how many lines are committed?
페드로: 얼마나 많은 줄이 커밋되었는지 누가 신경이나 쓰나요?

Eve: Someone cares.
이브: 신경쓰는 사람이 있을 수 있죠.

Pedro: Let's see where is the problem
페드로: 어디가 문제인지 봅시다.

[source, java]
....
class OldServlet {
  @Autowired
  RequestExtractorService requestExtractorService;
  @Autowired
  RequestValidatorService requestValidatorService;
  @Autowired
  TransformerService transformerService;
  @Autowired
  ResponseBuilderService responseBuilderService;

  public Response service(Request request) {
    RequestRaw rawRequest = requestExtractorService.extract(request);
    RequestRaw validated = requestValidatorService.validate(rawRequest);
    RequestRaw transformed = transformerService.transform(validated);
    Response response = responseBuilderService.buildResponse(transformed);
    return response;
  }
}
....

Eve: Oh shi...
이브: 오 이런...

Pedro: That's our internal API for developers, every time they need to process request, inject 4 services, include all imports, and write this code.
페드로: 이것은 개발자를 위한 내부 API에요. 요청을 처리할 때마다, 서비스 4개를 써야 하는데, 관련된 모든 임포트를 포함해야 하고, 그래서 이런 코드가 된 거죠.

Eve: Let's refactor it with...
이브: 리팩토링을 해보죠...그러니까...

Pedro: ...Facade pattern. We resolve all dependencies to a single point of access and simplify API usage.
페드로: ...파사드 패턴. 모든 의존성(dependencies)을 하나의 접점으로 모아서 API를 단순화하죠.

[source, java]
....
public class FacadeService {
  @Autowired
  RequestExtractorService requestExtractorService;
  @Autowired
  RequestValidatorService requestValidatorService;
  @Autowired
  TransformerService transformerService;
  @Autowired
  ResponseBuilderService responseBuilderService;

  RequestRaw extractRequest(Request req) {
    return requestExtractorService.extract(req);
  }

  RequestRaw validateRequest(RequestRaw raw) {
    return requestValidatorService.validate(raw);
  }

  RequestRaw transformRequest(RequestRaw raw) {
    return transformerService.transform(raw);
  }

  Response buildResponse(RequestRaw raw) {
    return responseBuilderService.buildResponse(raw);
  }
}
....

Pedro: Then if you need any service or set of services in the code you just injecting facade to your code
페드로: 그래서 어떤 서비스, 혹은 일단의 서비스가 필요하게 되면 단지 파사드만 쓰면 되죠.

[source, java]
....
class NewServlet {
  @Autowired
  FacadeService facadeService;

  Response service(Request request) {
    RequestRaw rawRequest = facadeService.extractRequest(request);
    RequestRaw validated = facadeService.validateRequest(rawRequest);
    RequestRaw transformed = facadeService.transformRequest(validated);
    Response response = facadeService.buildResponse(transformed);
    return response;
  }
}
....

Eve: Wait, you've just moved all dependencies to one and everytime using this one, correct?
이브: 잠깐만요, 방금 모든 의존성을 한 곳으로 옮기고, 매번 그것을 사용한다...라는 거죠?

Pedro: Yes, now everytime some functionality is needed, use FacadeService. Dependency is already there.
페드로:네, 어떤 기능이 필요할 때마다, FacadeService를 사용하죠. 필요한 의존성은 이미 거기에 있으니까요.

Eve: But we did the same in Mediator pattern?
이브: 하지만 중개자(Mediator) 패턴에서도 같은 일을 했잖아요?

Pedro: Mediator is behavioral pattern. We resolved all dependency to Mediator and added new behavior to it.
페드로: 중개자는 행위 패턴이죠. 모든 의존성을 중개자에게 몰아넣고, 거기에 새로운 행위를 추가하죠.

Eve: And facade?
이브: 그러면 파사드는?

Pedro: Facade is structural, we don't add new functionality, we just expose existing functionality with facade.
페드로: 파사드는 구조 패턴이죠, 파사드 패턴에는 새로운 기능을 추가하지 않아요, 그냥 기존 기능들을 노출할 뿐이죠.

Eve: Got it. But seems that pattern very loud word for such little tweak.
이브: 알겠어요. 하지만 그런 작은 차이에 붙이는 이름 치고는 정말 별나게 거창한 이름이군요.

Pedro: Maybe.
페드로: 아마도.

Eve: Here is clojure version using structure by namespaces
이브: 다음 클로저 코드는 이름공간들을 가져와서 사용하고 있어요.

[source, clojure]
....
(ns application.old-servlet
  (:require [application.request-extractor :as re])
  (:require [application.request-validator :as rv])
  (:require [application.transformer :as t])
  (:require [application.response-builder :as rb]))

(defn service [request]
  (-> request
      (re/extract)
      (rv/validate)
      (t/transform)
      (rb/build)))
....

Eve: Exposing all services via facade.
이브: 파사드로 모든 서비스를 노출시키고

[source, clojure]
....
(ns application.facade
  (:require [application.request-extractor :as re])
  (:require [application.request-validator :as rv])
  (:require [application.transformer :as t])
  (:require [application.response-builder :as rb]))

(defn request-extract [request]
  (re/extract request))

(defn request-validate [request]
  (rv/validate request))

(defn request-transform [request]
  (t/transform request))

(defn response-build [request]
  (rb/build request))
....

Eve: And use it.
이브: 그리고 사용하면 되죠.

[source, clojure]
....
(ns application.old-servlet
  (:use [application.facade]))

(defn service [request]
  (-> request
      (request-extract)
      (request-validate)
      (request-transform)
      (request-build)))
....

Pedro: What the difference between :use and :require?
페드로: :use와 :require의 차이는 뭐죠?

Eve: They are almost similar, but with :require you expose functionality via namespace qualificator (namespace/function) where with :use you can refer to it directly (function)
이브: 거의 비슷해요, 하지만 :require는 이름공간을 매번 함수 앞에 붙여줘야 하는 반면, :use는 바로 그럴 필요 없이 바로 사용가능하죠.

Pedro: So, :use is better.
페드로: 그러면, :use가 더 좋네요.

Eve: No, be aware of :use because it can conflict with existing names in your namespace.
이브: 아뇨, :use는 조심해야 해요. 기존 이름공간에서 같은 이름을 사용하면 충돌이 날 수 있죠.

Pedro: Oh, I see your point. And every time you call (:use [application.facade]) in some namespace all existing functionality from facade is available?
페드로: 오, 무슨 말인지 알겠어요. 어떤 이름공간에서 (:use [application.facade])를 호출할 때마다, 파사드에 있는 함수들 모두가 사용 가능하다?

Eve: Yes.
이브: 네.

Pedro: Pretty the same.
페드로: 아주 비슷하네요.

== Episode 15: Singleton
== 에피소드 15: 싱글톤(Singleton) 패턴

[sidebar]
....
Feverro O'Neal complains that we have a lot of different styles for UI.
Force one per application UI configuration.
페베로 오닐(Feverro O'Neal)은 UI 스타일이 너무 다양하다고 불평한다.
어플리케이션의 UI 설정에 하나의 스타일만 쓰도록 하자.
....

Pedro: But wait, there was requirement to save UI style per user.
페드로: 하지만 잠깐만요, 유저마다 서로 다른 UI 스타일을 저장하라는 요구 사항이 있었죠.

Eve: Probably it was changed.
이브: 그 요구사항이 바뀌었어요.

Pedro: Ok, then we should just save configuration to Singleton and use it from all the places.
페드로: 오케이, 그러면 설정 사항을 싱글톤에 저장하고 모든 곳에서 싱글톤을 사용하면 돼요.

[source, java]
....
public final class UIConfiguration {
  public static final UIConfiguration INSTANCE = new UIConfiguration("ui.config");

  private String backgroundStyle;
  private String fontStyle;
  /* other UI properties */

  private UIConfiguration(String configFile) {
    loadConfig(configFile);
  }

  private static void loadConfig(String file) {
    // process file and fill UI properties
    INSTANCE.backgroundStyle = "black";
    INSTANCE.fontStyle = "Arial";
  }

  public String getBackgroundStyle() {
    return backgroundStyle;
  }

  public String getFontStyle() {
    return fontStyle;
  }
}
....

Pedro: That way all configuration will be shared across the UIs.
페드로: 저런 식으로 모든 설정 정보가 UI들 사이에서 공유되는 거죠.

Eve: Yes, but...why so much code?
이브: 네, 하지만... 코드가 왜 이리 많죠?

Pedro: We guarantee that only one instance of UIConfiguration will exist.
페드로: ``UIConfiguration``의 인스턴스가 오직 하나만 존재하도록 보장한거죠.

Eve: Let me ask you: what's the difference between singleton and global varaible.
이브: 물어볼 게 있어요. 싱글톤과 전역변수의 차이가 뭐죠?

Pedro: What?
페드로: 뭐라구요?

Eve: ...the difference between singleton and global variable.
이브: ...싱글톤과 전역 변수의 차이요.

Pedro: Java does not support global variables.
페드로: 자바는 전역변수를 지원하지 않아요.

Eve: But UIConfiguration.INSTANCE is global variable.
이브: 하지만 ``UIConfiguration.INSTANCE``는 전역변수에요.

Pedro: Well, sort of.
페드로: 글쎄요, 비슷하긴 하죠.

Eve: Your code is just simple def in clojure.
이브: 저 자바 코드는 클로저에서는 그냥 단지 def일 뿐이죠.

[source, clojure]
....
(def ui-config (load-config "ui.config"))

(defn load-config [config-file]
  ;; process config file and return map with configuratios
  {:bg-style "black" :font-style "Arial"})
....

Pedro: But, how do you change the style?
페드로: 하지만, 스타일을 어떻게 바꾸죠?

Eve: The same way you will change it in your code.
이브: 자바에서 하는 것과 똑같은 방식으로요.

Pedro: Uhm... Ok, we need a simple tweak. Make UIConfiguration.loadConfig is public and call it when the configuration changes.
페드로: 음... 오케이, 살짝 바꿔볼게요. ``UIConfiguration.loadConfig``를 public으로 만들고, 설정이 바뀔 때 이 메소드를 호출하는 거죠.

Eve: Then we make ui-config an atom and call swap! when configuration changes.
이브: 그러면 ``ui-config``를 아톰으로 하고, 설정이 바뀌면 ``swap!``을 호출하면 돼요.

Pedro: But atoms are useful only in concurrent environment.
페드로: 하지만 아톰은 병행 프로그래밍 상황에서만 유용하잖아요.

Eve: First, yes, they useful, but NOT only in concurrent environment. Second, atom read is not as slow as you think. Third, it changes the state of UI configuration atomically
이브: 맞아요, 유용하죠. 하지만 병행 프로그래밍 상황에만 그런 건 아니에요. 그리고 아톰을 읽는 것은 생각만큼 느리지 않아요. 마지막으로 아톰은 UI 설정을 원자적으로 바꾸죠.

Pedro: It is redundant for such simple example.
페드로: 저런 단순한 예제에 사용하기에는 아톰이 좀 과분해 보이네요.

Eve: No, it is not. There is a posibility that UI configuration changes and some renders read new backgroundStyle, but old fontStyle
이브: 아니요, 그렇지 않아요. 아톰처럼 원자적으로 변경하지 않으면, UI 설정이 바뀔 때 랜더러들이 ``backgroundStyle``는 바뀐 값으로, ``fontStyle``은 이전 값 으로 읽을 가능성이 있어요.

Pedro: Ok, use synchronized for loadConfig
페드로: 그러면, ``loadConfig``에 ``synchronized``를 사용하면 돼요.

Eve: Then you must use synchonized on getters as well, it is slow.
이브: 그렇게 되면 getter들에도 ``synchonized``를 사용해야 하는데, 그러면 느려지죠.

Pedro: There is still Double-Checked Locking idiom
페드로: Double-Checked Locking 이디엄을 쓰면 돼요.

Eve: Double-checked locking is clever but broken
이브: Double-Checked Locking은 좋은 방법이긴 하지만, 원자성을 완벽하게 보장해 주지는 않죠.footnote:[link:http://www.javaworld.com/article/2074979/java-concurrency/double-checked-locking--clever--but-broken.html[Double-checked locking: Clever, but broken]]

Pedro: Ok, I give up, you won.
페드로: 오케이, 포기, 당신이 이겼어요.


== Episode 16: Chain Of Responsibility
== 에피소드 16: 책임 연쇄(Chain Of Responsibility) 패턴

[sidebar]
....
New York marketing organization "A Profit NY" opened request to filter profanity words from their public chat system.
뉴욕의 마케팅 조직인 "A Profit NY"는 그들의 공개 채팅 시스템에서 비속어 필터링을 요청했다.
....

Pedro: Fuck, they don't like the word "fuck"?
페드로: 젠장, 그들은 '젠장'이라는 말을 싫어하나?

Eve: It is profit organization, they lose money if someone use profanity words in public chat.
이브: 수익을 내야 하는 조직이니, 공개 채팅에서 누군가 비속어를 사용하면 수익을 잃겠죠.

Pedro: Who defined profanity words list?
페드로: 비속어 리스트는 누가 만들죠?

Eve: George Carlin
이브: 조지 칼린이요.footnote:[지금은 고인이 된 미국 스탠드업 코미디의 대부. 그의 유머 소재는 주로 미국 현대사회의 어두운 이면에 집중되어 있으며, 가끔 영어 표현의 부조리함도 주 소재로 삼곤 했다. 미정부의 공중파에서의 부적절한 내용에 대한 규제를 용인한 미법원의 판결을 주제로 한  “7가지 비속어들"(Seven Dirty Words)이라는 공연을 하고 공연 직후 경찰에 체포 되었다. 이 사건으로 그는 더 유명해졌다.]

Watching and laughing
리스트를 보다가 웃으며

Pedro: Ok, so let's just add a filter to replace these rude words with the asterisks.
페드로: 오케이, 비속어들을 별표로 바꾸는 필터를 추가해 봅시다.

Eve: Make sure your solution is extendable, other filters could be applied.
이브: 그 솔루션은 확장성이 있어야 해요, 다른 필터도 적용될 수도 있어야 하거든요.

Pedro: Chain of Responisibility seems like a good pattern candidate for that. First of all we make some abstract filter.
페드로: 책임 연쇄 패턴은 여기에 딱 맞는 패턴인 것 같네요. 일단 먼저 추상 필터를 만들어 보죠.


[source, java]
....
public abstract class Filter {
  protected Filter nextFilter;

  abstract void process(String message);

  public void setNextFilter(Filter nextFilter) {
    this.nextFilter = nextFilter;
  }
}
....

Pedro: Then, provide implementation for each specific filter you want to apply
페드로: 그리고 나서 실제로 적용할 필터들 구현해 봅시다.


[source, java]
....
class LogFilter extends Filter {
  @Override
  void process(String message) {
    Logger.info(message);
    if (nextFilter != null) nextFilter.process(message);
  }
}

class ProfanityFilter extends Filter {
  @Override
  void process(String message) {
    String newMessage = message.replaceAll("fuck", "f*ck");
    if (nextFilter != null) nextFilter.process(newMessage);
  }
}

class RejectFilter extends Filter {
  @Override
  void process(String message) {
    System.out.println("RejectFilter");
    if (message.startsWith("[A PROFIT NY]")) {
      if (nextFilter != null) nextFilter.process(message);
    } else {
      // reject message - do not propagate processing
    }
  }
}

class StatisticsFilter extends Filter {
  @Override
  void process(String message) {
    Statistics.addUsedChars(message.length());
    if (nextFilter != null) nextFilter.process(message);
  }
}
....

Pedro: And finally build a chain of filters which defines an order how message will be processed.
페드로: 마지막으로 메시지가 처리되는 순서를 정의하는 필터의 연쇄를 만듭시다.


[source, java]
....
Filter rejectFilter = new RejectFilter();
Filter logFilter = new LogFilter();
Filter profanityFilter = new ProfanityFilter();
Filter statsFilter = new StatisticsFilter();

rejectFilter.setNextFilter(logFilter);
logFilter.setNextFilter(profanityFilter);
profanityFilter.setNextFilter(statsFilter);

String message = "[A PROFIT NY] What the fuck?";
rejectFilter.process(message);
....

Eve: Ok, now clojure turn. Just define each filter as a function.
이브: 오케이, 이제 클로저로 해보죠. 각 필터는 함수로 정의합니다.


[source, clojure]
....
;; define filters

(defn log-filter [message]
  (logger/log message)
  message)

(defn stats-filter [message]
  (stats/add-used-chars (count message))
  message)

(defn profanity-filter [message]
  (clojure.string/replace message "fuck" "f*ck"))

(defn reject-filter [message]
  (if (.startsWith message "[A Profit NY]")
    message))
....

Eve: And use some-> macro to chain filters
이브: 그리고 ``some->`` 매크로를 사용해서 필터들을 연결합니다.


[source, clojure]
....
(defn chain [message]
  (some-> message
          reject-filter
          log-filter
          stats-filter
          profanity-filter))
....

Eve: You see how much it is easier, you don't need every-time call if (nextFilter != null) nextFilter.process(), because it's natural. The next filter defined at the some-> level naturally, instead of calling manuall setNext.
이브: 얼마나 쉬운지 아시겠죠? 너무 자연스러워서, 매번 ``if (nextFilter != null) nextFilter.process()`` 호출할 필요가 없어요. ``some->``에서 정의한 다음 필터는 ``setNext``를 호출할 필요 없이, 자연스럽게 연결돼요.

Pedro: That's definitely better for composability, but why did you use some-> instead of ->?
페드로: 확실히 조립성(composability)이 더 좋네요. 하지만 왜 ``->``가 아닌 ``some->``을 썼죠?

Eve: Just for reject-filter. It could stop further processing, so some-> returns nil as soon as nil encountered as a filter
이브: ``reject-filter`` 때문이죠. 더 이상 진행할 필요가 없을 수 있는데, 그래서 필터가 nil을 반환하면 ``some->``은 곧바로 nil을 반환하죠.

Pedro: Could you explain more?
페드로: 좀 더 설명해 주실 수 있어요?

Eve: Look at the usage
이브: 사용 예를 보시죠.

[source, clojure]
....
(chain "fuck") => nil
(chain "[A Profit NY] fuck") => "f*ck"
....

Pedro: Understood.
페드로: 이해됐어요.

Eve: Chain of Responsibility just an approach to function composition
이브: 책임 연쇄 패턴은 단지 함수 합성일 뿐인 거죠.

Episode 17: Composite
에피소드 17: 합성(Composite)패턴

[sidebar]
....
Actress Bella Hock don't see user avatars in our social network on her computer.
여배우인 벨라 호크(Bella Hock)가 소셜 네트워크에서 사용자 아바타를 보지 못하고 있다.

"Everything is black. Is it black holes?"
"모든 것이 검은 색이예요. 이거 블랙홀인가요?"
....

Pedro: It is black squares.
페드로: 이거 검정 사각형이네요.

Eve: Hmm, the same problem on our side.
이브: 흠, 이쪽도 같은 문제가 있어요.

Pedro: Seems, that latest feature broke user avatars.
페드로: 마지막에 추가된 기능이 사용자 아바타에 버그를 만든 것 같네요.

Eve: Strange, because avatars rendered the same way as other elements, but they are visible.
이브: 이상하네요, 아바타는 다른 요소들과 같은 방식으로 랜더링해요. 하지만 아바타는 눈에 보이는 거죠.

Pedro: Are you sure it rendered the same way?
페드로: 같은 방식으로 랜더링하는 거 확실해요?

Eve: Well...no
이브: 글쎄요... 아니요.


Digging code
코드를 파 본다.

Pedro: What the hell is going on here?
페드로: 도대체 이 코드들이 뭘 하는 거죠?

Eve: Someone copypasted code, but forgot to reflect changes in avatars.
이브: 누군가 복사해서 붙여넣기를 했네요. 하지만 아바타에 변경 사항을 반영하는 것을 잊었어요.

Pedro: Let's blame him, git-blame
페드로: 이 코드를 누가 작성했는지 확인해 보죠, ``git-blame``

Eve: Blame is good, but we need to fix the problem
이브: 확인하는 것도 좋긴 한데, 이 문제를 고칠 필요가 있어요.

Pedro: It's simple just additional line here.
페드로: 여기에 한 줄 추가하면 간단하죠.

Eve: I mean, really solve the problem. Why do we need two similar snippets of code to process the same blocks?
이브: 제 말은, 진짜 문제를 풀자는 거에요. 같은 블럭들을 처리하는데, 비슷한 코드 2개가 왜 필요하죠?

Pedro: Correct, I think we could use Composite pattern to handle rendering of the whole page. Our smallest element to render is block.
페드로: 맞네요. 합성 패턴을 사용해서 전체 페이지 랜더링을 처리할 수 있을 것 같아요. 랜더링하는 가장 작은 요소는 블럭이구요.

[source, java]
....
public interface Block {
  void addBlock(Block b);
  List<Block> getChildren();

  void render();
}
....

Pedro: Obviously blocks may contain other blocks, that's the point of Composite pattern. We may create some specific blocks.
페드로: 당연히 블럭은 다른 블럭을 포함할 수 있어요. 그게 바로 합성 패턴이죠. 구체적인 블럭 몇 개를 만들어 보죠.

[source, java]
....
public class Page implements Block { }
public class Header implements Block { }
public class Body implements Block { }
public class HeaderTitle implements Block { }
public class UserAvatar implements Block { }
....

Pedro: And treat every specific element as a Block
페드로: 그리고 모든 구체적인 요소들을 ``Block``인 것처럼 다룰 수 있죠.

[source, java]
....
Block page = new Page();
Block header = new Header();
Block body = new Body();
Block title = new HeaderTitle();
Block avatar = new UserAvatar();

page.addBlock(header);
page.addBlock(body);
header.addBlock(title);
header.addBlock(avatar);

page.render();
....

Pedro: This is a structural pattern, a good way to compose objects. That's why it is called composite
페드로: 이것은 구조 패턴이에요. 개체들을 합성하는 좋은 방법이죠. 그래서 __합성__이라고 불리는 거죠.

Eve: Hey, composite is a simple tree structure.
이브: 저기요. 합성은 단순한 트리 구조네요.

Pedro: Yes.
페드로: 그렇죠.

Eve: There is pattern for every datastructure?
이브: 모든 자료구조를 위한 패턴이 있나요?

Pedro: No, just for list and tree.
페드로: 아니요. 단지 리스트와 트리만을 위한 패턴이 있죠.

Eve: Actually, tree can be represented as a list
이브: 사실, 트리는 리스트로 표현할 수 있어요.

Pedro: How?
페드로: 어떻게요?

Eve: First element of a list is a node value, next elements are children, each of them is...
이브: 리스트의 첫 요소는 노드이고요. 그 다음 요소들은 자식들이., 그리고 그들 각각은...

Pedro: I understand.
페드로: 이해했어요.

Eve: To be specific, here is the tree
이브: 좀 더 설명하자면, 다음과 같이 트리가 있어요.

....
        A
     /  |  \
    B   C   D
    |   |  / \
    E   H J   K
   / \       /|\
  F   G     L M N
....

Eve: And here is the list represents this tree
이브: 그리고 이 트리를 나타내는 리스트가 다음처럼 돼요.

[source, clojure]
....
(def tree
  '(A (B (E (F) (G))) (C (H)) (D (J) (K (L) (M) (N)))))
....

Pedro: It's a plenty of parentheses!
페드로: 괄호가 많네요!

Eve: They define structure, you know
이브: 괄호는 구조를 만드는 거죠, 알다시피.

Pedro: But it's hard to understand
페드로: 하지만 파악하기 어려워요.

Eve: It's easy for machine, there is awesome tree-seq function to process the tree.
이브: 기계한테는 쉽죠. 트리를 처리하는 ``tree-seq``라는 멋진 함수가 있어요.

[source, clojure]
....
(map first (tree-seq next rest tree)) => (A B E F G C H D J K L M N)
....

Eve: If you need more advanced traversals, use clojure.walk
이브: 더 복잡한 순회가 필요하다면, ``clojure.walk``를 사용하면 돼요.

Pedro: I don't know, everything seems just a bit harder.
페드로: 모르겠네요, 모든 것이 좀 더 어려워 보이네요.

Eve: No, you define the whole tree with one datastructure and use one function to operate on it.
이브: 아니요, 모든 트리를 자료구조 하나로 정의하고, 그것에 대해 동작하는 하나의 함수만을 사용하는 것이예요.

Pedro: What this function will do?
페드로: 이 함수가 하는 일이 뭐죠?

Eve: It traverses the tree and applies to every node, so in our case it can render each component.
이브: 트리를 순회하면서 모든 노드에 함수를 적용하는 거죠, 우리의 경우에는 각 컴포넌트들을 랜더링하는 거구요.

Pedro: I don't know, maybe I am too young for the trees, let's move forward.
페드로: 모르겠네요, 전 트리를 다루기에는 경험이 부족한가 봐요. 다음으로 가죠.


Episode 18. Factory Method
== 에피소드 18. 팩토리 메ㅜ소드(Factory Method) 패턴

[sidebar]
....
Sir Dry Bang suggest to create new levels for their popular game. More levels - more money.
드라이 뱅(Dry Bang)씨가 그들의 인기 게임에 새로운 레벨를 만들자고 제안한다. 레벨이 많으면 그만큼 돈도 번다.
....

Pedro: How can we create new levels?
페드로: 새 레벨들을 어떻게 만들 수 있나요?

Eve: Just change assets and add new blocks: paper, wood, iron...
이브: 그저 리소스를 바꾸고 블럭들을 새로 만들고, 종이, 나무, 철...

Pedro: It's too silly, isn't it?
페드로: 그건 너무 바보같지 않아요?

Eve: The whole game is too silly. If user pay for color hats for their characters, then they will pay for wooden blocks as well.
이브: 게임 전체가 바보같죠. 유저들이 자신의 캐릭터가 쓸 색깔 모자에 돈을 지불한다면, 나무 블럭에도 지불할 거에요.

Pedro: I think it's a crap, but anyway, let's make MazeBuilder generic and add specific builder for each type of the block. It's a Factory Method pattern.
페드로: 말도 않되는 거 같지만, 어쨌든, ``MazeBuilder``를 일반적으로 만들고 블럭의 각 타입에 맞는 빌더를 추가합시다. 그건 팩토리 메서드 패턴이죠.

[source, java]
....
class Maze { }
class WoodMaze extends Maze { }
class IronMaze extends Maze { }

interface MazeBuilder {
  Maze build();
}

class WoodMazeBuilder {
  @Override
  Maze build() {
    return new WoodMaze();
  }
}

class IronMazeBuilder {
  @Override
  Maze build() {
    return new IronMaze();
  }
}
....

Eve: Isn't it obvious that IronMazeBuilder will return IronMazes?
이브: ``IronMazeBuilder``가 ``IronMazes``를 리턴하는 것은 당연하지 않나요?

Pedro: Not for program. But see, to make a maze from another blocks we just change implementation responsible for block creation.
페드로: 프로그램한테는 당연한 게 아니죠. 하지만 봅시다, 다른 블럭으로부터 미로를 만들기 위해 우리는 블럭 생성에 책임이 있는 구현체를 단지 변경했어요.

[source, java]
....
MazeBuilder builder = new WoodMazeBuilder();
Maze maze = builder.build();
....

Eve: I've seen something similar before.
이브: 전에 비슷한 것을 봤어요.

Pedro: What exactly?
페드로: 무엇을요?

Eve: For me it seems like a strategy or state pattern.
이브: 저에게는 이것은 전략 패턴이나 상태 패턴과 비슷해 보여요.

Pedro: No way! Strategy is about performing specific operations and factory is for creating specific object.
페드로: 말도 안돼요. 전략 패턴은 특정 동작을 수행하는 것에 대한 것이고, 팩토리 패턴은 특정 객체를 만들기 위한 것이에요.

Eve: But create is an operation as well.
이브: 하지만 생성도 또한 동작이죠.

[source, clojure]
....
(defn maze-builder [maze-fn])

(defn make-wood-maze [])
(defn make-iron-maze [])

(def wood-maze-builder (partial maze-builder make-wood-maze))
(def iron-maze-builder (partial maze-builder make-iron-maze))
....

Pedro: Hm, seems similar.
페드로: 흠, 비슷해 보이네요.

Eve: Think about it.
이브: 생각해 보세요.

Pedro: Any usage examples?
페드로: 사용 예제 같은 게 있나요?

Eve: No, everything is obvious here, just re-read Strategy, State or TemplateMethod episodes.
이브: 아니요, 모든 것이 여기서는 뻔한거라, 그저 전략 패턴이나 상태 패턴, 그리고 템플릿 메서드 패턴 에피소드를 다시 읽으면 돼요.


Episode 19: Abstract Factory
== 에피소드 19: 추상 팩토리(Abstract Factory) 패턴

[sidebar]
....
Users are not buying new levels in the game. Saimank Gerr build a complains cloud and the most popular negative feedback words are: "ugly", "crap" and "shit".
사용자들이 게임의 새 레벨들을 사지 않고 있다. 세이망 게르(Saimank Gerr)가 불평과 관련된 워드클라우드를 만들었는데, 가장 많은 부정적 피드백 단어는 "추해", "형편 없어", "엉망이야" 이다.

Improve levels-building system.
레벨 구축 시스템을 개선하라.
....

Pedro: I said this is crap.
페드로: 내가 말했었죠, 이건 형편 없다고.

Eve: Sure, snow background with wooden walls, space invaders with wooden walls every setting with wooden walls.
이브: 확실히 그래요, 눈 배경에도 나무 벽이 있고, 우주 침략자들에도 나무 벽이 있고, 온통 나무 벽이에요.

Pedro: Then we must separate game worlds and build a set of specific objects for particular world.
페드로: 그러니 게임 세계를 레벨 별로 분리하고 각 레벨에 맞는 객체들을 만들어야 해요.

Eve: Explain.
이브: 설명해 주세요.

Pedro: Instead of using Factory Method for building specific blocks, we use Abstract Factory to build a set of related objects, to make a level look less crappy.
페드로: 구체적인 블럭을 만드는 데 팩토리 메소드 패턴 대신, 추상 팩토리 패턴을 이용해서 서로 관련된 객체들을 만들어 주면 레벨들이 좀 나아보일 거에요.

Eve: Example would be good.
이브: 예제가 있으면 좋겠어요.

Pedro: Code is my example. First we define abstract behaviour of level factory
페드로: 코드가 예제죠. 우선 레벨 팩토리에 추상 행위를 정의해요.

[source, java]
....
public interface LevelFactory {
  Wall buildWall();
  Back buildBack();
  Enemy buildEnemy();
}
....

Pedro: Then we have a hierarchy of objects that level consists of
페드로: 그리고 레벨들을 구성하는 객체들의 계층도를 만듭니다.


[source, java]
....
class Wall {}
class PlasmaWall extends Wall {}
class StoneWall extends Wall {}

class Back {}
class StarsBack extends Back {}
class EarthBack extends Back {}

class Enemy {}
class UFOSoldier extends Enemy {}
class WormScout extends Enemy {}
....

Pedro: See? We have a specific object for each level, let's create factory for them.
페드로: 알겠나요? 각 레벨마다 고유한 객체들이 있죠. 이제 팩토리를 만들어 보죠.

[source, java]
....
class SpaceLevelFactory implements LevelFactory {
  @Override
  public Wall buildWall() {
    return new PlasmaWall();
  }

  @Override
  public Back buildBack() {
    return new StarsBack();
  }

  @Override
  public Enemy buildEnemy() {
    return new UFOSoldier();
  }
}

class UndergroundLevelFactory implements LevelFactory {
  @Override
  public Wall buildWall() {
    return new StoneWall();
  }

  @Override
  public Back buildBack() {
    return new EarthBack();
  }

  @Override
  public Enemy buildEnemy() {
    return new WormScout();
  }
}
....

Pedro: Each implementation of level factory creates related objects for level. Levels will look less crappy for sure.
페드로: 각 레벨 팩토리의 클래스들은 자신의 레벨과 관련된 객체들을 만들어요. 레벨들은 이제 확실히 더 나아졌어요.

Eve: Let me understand. I really can't spot the difference.
이브: 어디 봅시다. 그런데 어떤 차이가 있는지 모르겠네요.

Pedro: Factory Method defers object creation to a subclasses, Abstract Factory do the same but for a set of related object.
페드로: 팩토리 메서드 패턴은 객체 생성을 하위 클래스로 넘겨요. 추상 팩토리 패턴은 같은 일을 하지만 서로 관련된 객체들에 대해서 그렇게 하죠.

Eve: Aha, that means I need to pass set of related functions to abstract builder
이브: 아하, 추상 빌더에 서로 관련된 함수들을 전달하면 된다는 의미로군요.


[source, clojure]
....
(defn level-factory [wall-fn back-fn enemy-fn])

(defn make-stone-wall [])
(defn make-plasma-wall [])

(defn make-earth-back [])
(defn make-stars-back [])

(defn make-worm-scout [])
(defn make-ufo-soldier [])

(def underground-level-factory
  (partial level-factory
           make-stone-wall
           make-earth-back
           make-worm-scout))

(def space-level-factory
  (partial level-factory
           make-plasma-wall
           make-stars-back
           make-ufo-soldier))
....

Pedro: I knew.
페드로: 알겠어요.

Eve: Everything is fair. Your lovely "set of related Xs", where X is a function
이브: 모든 것이 깔끔하죠. 당신이 좋아하는 "서로 관련된 X들의 집합", 여기서 X는 함수죠.

Pedro: Yes, clarify, what partial is.
페드로: 네, 그런데 ``partial``은 뭐죠?

Eve: Provide some parameters for function. So, underground-level-factory knows how to construct walls, backs and enemies. Everything other inherited from abstract level-factory function.
이브: 함수에 파라미터를 일부만 주는 거에요. 그래서 ``underground-level-factory``는 wall과 back과 enemy를 구축하는 법을 알죠. 나머지 작업은 ``level-factory`` 추상 함수가 제공하죠.

Pedro: Handy.
페드로: 편리하네요.


Episode 20: Adapter
== 에피소드 20: 어댑터(Adapter) 패턴

[sidebar]
....
Deam Evil conducts a medieval tournament for knights. The prize is $100.000
딤 이블(Deam Evil)은 기사의 결투 시합 게임을 한다. 상금은 10만 달러이다.

I'll pay you the half if you break the system and allow my armed commando to take part in competition.
"만약 당신들이 시스템을 깨고 나의 중무장한 코만도를 이 시합에 넣어 주면 상금의 반을 주겠소."
....

Pedro: Finally we've got interesting work.
페드로: 드디어 재밌는 일을 하게 되네요.

Eve: Funny to see the competition. Especially, M16 vs Iron Sword part.
이브: 시합을 보는 것은 재밌죠. 특히 M16과 철검의 대결이라면...

Pedro: Knights have a good armor.
페드로: 기사들은 좋은 갑옷을 입고 있어요.

Eve: F1 grenade does not care about armor.
이브: F1 수류탄한테는 갑옷은 소용 없어요.

Pedro: Nevermind, we do the work, we get the money.
페드로: 신경쓸 거 없어요, 우리는 일을 하고, 돈을 받으면 돼요.

Eve: Fifty grands - nice compensation
이브: 5만 달러 - 괜찮은 액수네요.

Pedro: Yes, look at this, I've stolen sources of the competition system, though it is not possible to modify their sources, we can find some vulneravility.
페드로: 네, 이것을 보세요, 시합 시스템의 소스를 훔쳤어요. 소스를 고칠 수는 없지만, 약점을 찾을 수 있어요.

Eve: Here it is
이브: 여기 있어요.


[source, java]
....
public interface Tournament {
  void accept(Knight knight);
}
....

Pedro: Aha! System validates only incoming types via Knight interface. All we need to do is to adapt commando to be a knight. Let's see how knight look like
페드로: 아하! 시스템은 ``Knight`` 인터페이스로 들어오는 입력 타입만을 검사하고 있어요. 우리는 그저 commando를 기사로 __맞추어 넣기(adapt)__만 하면 돼요. 기사가 어떤 모양인지 봅시다.

[source, java]
....
interface Knight {
  void attackWithSword();
  void attackWithBow();
  void blockWithShield();
}

class Galahad implements Knight {
  @Override
  public void blockWithShield() {
    winkToQueen();
    take(shield);
    block();
  }

  @Override
  public void attackWithBow() {
    winkToQueen();
    take(bow);
    attack();
  }

  @Override
  public void attackWithSword() {
    winkToQueen();
    take(sword);
    attack();
  }
}
....

Pedro: To accept the commando let's take an old implementation
페드로: 코만도를 받기 위해서 이전 구현 코드를 가져옵시다.

[source, java]
....
class Commando {
    void throwGrenade(String grenade) { }
    shot(String rifleType) { }
}

Pedro: And adapt it.
페드로: 그리고 코만도를 기사로 맞추어 줍니다.

class Commando implements Knight {
  @Override
  public void blockWithShield() {
    // commando don't block
  }

  @Override
  public void attackWithBow() {
    throwGrenade("F1");
  }

  @Override
  public void attackWithSword() {
    shotWithRifle("M16");
  }
}
....

Pedro: That's it.
페드로: 됐어요.

Eve: It's simpler in clojure.
이브: 클로저로는 더 쉬워요.

Pedro: Really?
페드로: 정말로요?

Eve: We don't love types so their validation won't work at all
이브: 클로저는 타입을 쓰지 않아서 타입 검사는 전혀 동작하지 않죠.

Pedro: So, how do you replace knight with commando?
페드로: 그러면 기사를 어떻게 코만도로 바꾸죠?

Eve: Basically, what knight is? It's a map, consists of data and behaviour
이브: 기본적으로 기사란 무엇이죠? 그것은 맵이죠, 데이타와 행위로 된.


[source, clojure]
....
{:name "Lancelot"
 :speed 1.0
 :attack-bow-fn attack-with-bow
 :attack-sword-fn attack-with-sword
 :block-fn block-with-shield}
....

Eve: To adapt commando, just pass his functions instead original ones
이브: 코만도를 기사로 맞추기 위해서는 단지 원래의 것 대신 코만도의 함수를 전달하면 되요.

[source, clojure]
....
{:name "Commando"
 :speed 5.0
 :attack-bow-fn (partial throw-grenade "F1")
 :attack-sword-fn (partial shot "M16")
 :block-fn nil}
....

Pedro: How did we share money?
페드로: 우리는 돈을 어떻게 나눌까요?

Eve: 50/50
이브: 50 대 50

Pedro: I wrote more code, I want 70
페드로: 내가 더 많은 코드를 작성했으니, 전 70을 원해요.

Eve: Ok, 70/70
이브: 오케이, 70 대 70

Pedro: Deal.
페드로: 좋아요.


Episode 21: Decorator
== 에피소드 21: 데코레이터(Decorator) 패턴

[sidebar]
....
Podrea Vesper caught us on cheating for the tournament. We have a choice: to be busted by police or to help his super knight to take part in competition
포드래 베스퍼(Podrea Vesper)는 시합에서 우리가 속임수를 사용한 것을 적발했다. 우리에게는 하나의 선택권이 있다: 경찰에 체포되거나 그의 슈퍼 기사를 시합에 넣어주는 것이다.
....

Pedro: I don't wanna go to prison.
페드로: 난 감옥에 가고 싶지 않아요.

Eve: Me either.
이브: 저도요.

Pedro: Let's cheat for him one more time.
페드로: 그를 위해 한번 더 해보죠.

Eve: This is the same solution, isn't it?
이브: 같은 방식이죠?

Pedro Similar, but not the same. Commando was a soldier and they are not allowed on the tournament. We adapted it. But knight is allowed for tournament we don't need to adapt it, we must add functionality to existing object.
페드로: 비슷하지만, 똑같지는 않아요. 코만도는 군인이어서 시합에 참여하는 것이 허용되지 않죠. 그래서 우리가 맞추어 넣은 거구요. 하지만 기사는 시합 참여가 가능하니, 맞출 필요가 없구요. 기존 것에 기능을 추가하면 되요.

Eve: Inheritance or composition?
이브: 상속이나 합성?

Pedro: Composition, the main goal of decorator to change behaviour at a runtime
페드로: 합성, 런타임에 행위를 바꾸는 데코레이터 패턴의 주요 목적이죠.

Eve: So how we deal with this super knight?
이브: 그러면 이 슈퍼 기사를 어떻게 할까요?

Pedro: They plan to use Galahad knight and decorate it with more HP and Power Armor
페드로: 그들은 ``Galahad`` 기사를 사용해서 더 많은 HP와 강력 갑옷을 장식할 계획이에요.

Eve: Heh, funny that cops are playing Fallout
이브: 헤, 경찰이 게임을 하다니 재밌네요.

Pedro: Yeah, let's make knight an abstract class
페드로: 네, 기사를 추상 클래스로 만듭시다.


[source, java]
....
public class Knight {
    protected int hp;
    private Knight decorated;

    public Knight() { }

    public Knight(Knight decorated) {
        this.decorated = decorated;
    }

    public void attackWithSword() {
        if (decorated != null) decorated.attackWithSword();
    }

    public void attackWithBow() {
        if (decorated != null) decorated.attackWithBow();
    }

    public void blockWithShield() {
        if (decorated != null) decorated.blockWithShield();
    }
}
....

Eve: So what we improved there?
이브: 그러면 저기서 무엇을 개선해야 되죠?

Pedro: First af all we make class Knight instead of interface to have access to hit points. Then we provide two diferent constructors, default for standard behaviour, and decorated, which delegates call to decorated object.
페드로: 인터페이스 대신에 클래스 ``Knight``를 만들어서 hp(hit point) 멤버변수에 접근해요. 그러고 나서 2개의 생성자를 만드는데, 하나는 표준 행위를 위한 디폴트이고, 다른 하나는 데코레이트된 객체에 호출을 위임하는 데코레이트된 생성자이죠.

Eve: Is it fair to use abstract class instead of interface?
이브: 인터페이스 대신 추상 클래스를 쓰는 게 맞아요?

Pedro: No, but we avoid two classes with similar behaviour and fill each decorated object with default implementation, instead of forcing to implement each of the methods.
페드로: 아니요, 하지만 비슷한 행위를 하는 2개의 클래스를 피하고, 각 데코레이트된 객체를 기본 구현으로 채우는 거죠. 각 메소드의 구현을 강제하는 대신.

Eve: Ok, what's about Power Armor?
이브: 오케이, 특수 갑옷은요?

Pedro: Easy as well
페드로: 역시 쉬워요.


[source, java]
....
public class KnightWithPowerArmor extends Knight {
    public KnightWithPowerArmor(Knight decorated) {
        super(decorated);
    }

    @Override
    public void blockWithShield() {
        super.blockWithShield();
        Armor armor = new PowerArmor();
        armor.block();
    }
}

public class KnightWithAdditionalHP extends Knight {
    public KnightWithAdditionalHP(Knight decorated) {
        super(decorated);
        this.hp += 50;
    }
}
....

Pedro: Two decorators that fulfils FBI requirements, and we able to create super knight, with behaviour like Galahad, but super armor and 50 more hit points.
페드로: 경찰의 요구 사항을 충족하는 2개의 데코레이터에요. 이제 슈퍼 기사를 만들 수 있어요. 이 슈퍼 기사는 Galahad와 같은 동작을 하지만, 특수 갑옷을 입고 있고, hp 점수도 50점 더 높아요.


[source, java]
....
Knight superKnight =
     new KnightWithAdditionalHP(
     new KnightWithPowerArmor(
     new Galahad()));
....

Eve: Nice trick!
이브: 괜찮은 트릭이네요.

Pedro: You are welcome to show the similar behaviour in clojure
페드로: 자 이제 클로저로 비슷한 행위를 보여줘 보시죠.

Eve: Here it is
이브: 여기요.


[source, clojure]
....
(def galahad {:name "Galahad"
              :speed 1.0
              :hp 100
              :attack-bow-fn attack-with-bow
              :attack-sword-fn attack-with-sword
              :block-fn block-with-shield})

(defn make-knight-with-more-hp [knight]
  (update-in knight [:hp] + 50))

(defn make-knight-with-power-armor [knight]
  (update-in knight [:block-fn]
             (fn [block-fn]
               (fn []
                 (block-fn)
                 (block-with-power-armor)))))

;; create the knight
(def superknight (-> galahad
                     make-knight-with-power-armor
                     make-knight-with-more-hp)
....

Pedro: The same functionality.
페드로: 똑같은 기능이네요.

Eve: Yes, just pay attention to power armor decorator.
이브: 네, 다만 특수 갑옷 데코레이터(make-knight-with-power-armor)만 주의해서 보세요.


Episode 22: Proxy
== 에피소드 22: 프록시(Proxy) 패턴

[sidebar]
....
Deren Bart manages the system for making mixed drinks. It is rigid system, because after making a drink Bart must manually subtract used ingredients from the bar. Do this automatically.
데렌 바트(Deren Bart)는 칵테일 만드는 시스템을 관리하고 있다. 이 시스템은 불편했는데, 칵테일을 만든 후 바트는 직접 손으로 쉐이커에서 남은 재료를 빼내야 했기 때문이다. 이것을 자동화하라.
....

Pedro: Can we get access to his codebase?
페드로: 바트의 코드 베이스에 접근할 수 있나요?

Eve: No, but he sent some APIs.
이브: 아니요, 하지만 바트가 API를 몇 개 보내줬어요.

[source, java]
....
interface IBar {
    void makeDrink(Drink drink);
}

interface Drink {
    List<Ingredient> getIngredients();
}

interface Ingredient {
    String getName();
    double getAmount();
}
....

Pedro: Bart doesn't want us to modify sources, instead we need to provide some additional implementation for IBar interface with autosubtracting used ingredients.
페드로: 바트는 소스에 손 대는 것을 원치 않아요, 대신에 ``IBar`` 인터페이스를 구현한 클래스를 추가로 몇 개 만들어서 남은 재료를 자동으로 제거할 필요가 있어요.

Eve: And what are we responsible for?
이브: 그러면 우리가 맡아야 할 일은 무엇인가요?

Pedro: Implementing Proxy Pattern, I've read about it some times ago.
페드로: 프록시 패턴을 구현하죠. 얼마 전에 그것에 대해 읽었어요.

Eve: I'm all listening.
이브: 어서 말해 봐요.

Pedro: Basically we delegate all existing functionality to standard IBar implementation and provide new functionality inside ProxiedBar
페드로: 기본적으로 기존 모든 기능은 ``IBar``를 구현한 표준(standard) 클래스에 위임하고, 새 기능은 ``ProxiedBar``에 넣는 것이죠.

[source, java]
....
class ProxiedBar implements IBar {
    BarDatabase bar;
    IBar standardBar;

    public void makeDrink(Drink drink) {
       standardBar.makeDrink(drink);
       for (Ingredient i : drink.getIngredients()) {
           bar.subtract(i);
       }
    }
}
....

Pedro: They need to replace StandardBar implementation with our ProxiedBar.
페드로: ``StandardBar`` 구현 클래스를 우리의 ``ProxiedBar``로 바꿔야 해요.

Eve: Seems super easy.
이브: 아주 간단해 보이네요.

Pedro: Yes, additional plus that we don't break existing functionality.
페드로: 네, 게다가 덤으로 우리가 기존 기능을 깨지 않아도 돼요.

Eve: Are you sure? We didn't run regression tests.
이브: 확실해요? 회귀 테스트를 하지 않았어요.

Pedro: Everything we do is delegating functionality to already tested StandardBar
페드로: 우리가 한 것은 단지 기능을 기존에 이미 테스트된 ``StandardBar``에 위임한 것일 뿐이에요.

Eve: But you also substracts used ingredients from BarDatabase
이브: 하지만 여전히 ``BarDatabase``에서 쓰다 남은 재료를 제거하고 있어요.

Pedro: We assume, they are decoupled.
페드로: 그것들은 분리되어 있어요.

Eve: Oh...
이브: 오...

Pedro: Does clojure have some alternative?
페드로: 클로저는 다른 방식이 있나요?

Eve: Well, I don't know. What I see here you are using function composition.
이브: 글쎄요, 모르겠네요. 제가 아는 바로는 함수 합성을 사용한다는 거죠.

Pedro: Explain.
페드로: 설명해 보세요.

Eve: IBar implementation is a set of functions, and another IBar is another set of functions. Everything you talking about additional implementation could be covered by function composition. It's like make-drink and after that subtract-ingredients from bar.
이브: ``IBar`` 구현은 함수의 집합이고, 다른 IBar는 또다른 함수의 집합이죠. 당신이 추가적으로 구현해야 할 모든 것은 함수 합성으로 다 취급되요. ``make-drink``하고, 그 다음 bar에서 ``subtract-ingredients`` 하는 것과 같은 거죠.

Pedro: Maybe code is more clear?
페드로: 코드를 보여주시는 게 더 좋지 않을까요?

Eve: Yes, but I don't think something special here
이브: 네, 하지만 뭐 별로 여기서 특별한 것은 없어요.


[source, clojure]
....
;; interface
(defprotocol IBar
  (make-drink [this drink]))

;; Bart's implementation
(deftype StandardBar []
  IBar
  (make-drink [this drink]
    (println "Making drink " drink)
    :ok))

;; our implementation
(deftype ProxiedBar [db ibar]
  IBar
  (make-drink [this drink]
    (make-drink ibar drink)
    (subtract-ingredients db drink)))

;; this how it was before
(make-drink (StandardBar.)
    {:name "Manhattan"
     :ingredients [["Bourbon" 75] ["Sweet Vermouth" 25] ["Angostura" 5]]})

;; this how it becomes now
(make-drink (ProxiedBar. {:db 1} (StandardBar.))
    {:name "Manhattan"
     :ingredients [["Bourbon" 75] ["Sweet Vermouth" 25] ["Angostura" 5]]})
....

Eve: We could leverage protocol and types to group set of functions as a single object.
이브: 함수의 집합을 단일 객체로 그룹화하기 위해 프로토콜과 타입을 이용하죠.

Pedro: Looks like clojure has object-oriented capabilities as well.
페드로: 클로저가 객체지향 능력 또한 갖춘 것처럼 보이네요.

Eve: Correct, moreover it has a reify function, which allow you to create proxies in a runtime
이브: 맞아요, 더욱이 ``reify``함수가 있는데, 이것을 이용하면 runtime에 프록시를 만들 수 있어요.

Pedro: Like class in a runtime?
페드로: 런타임용 class같은 건가요?

Eve: Sort of.
이브: 그 비슷하죠.


[source, clojure]
....
(reify IBar
  (make-drink [this drink]
    ;; implementation goes here
  ))
....

Pedro: Looks handy.
페드로: 간편해 보이네요.

Eve: Yes, but I still don't understand how it differs from Decorator.
이브: 네, 하지만 전 여전히 이것이 데코레이터 패턴과 어떻게 다른지 이해가 안돼요.

Pedro: They are completely different.
페드로: 그것들은 완전히 다르죠.

Eve: Decorator adds functionality to the same interface, and so does Proxy.
이브: 데코레이터는 같은 인터페이스에 기능을 추가하는데, 프록시도 마찬가지죠.

Pedro: Well, but Proxy is...
페드로: 글쎄요, 하지만 프록시는...

Eve: Even more, Adapter is not very different as well.
이브: 더욱이, 어댑터 또한 그리 다르지 않아요.

Pedro: It uses another interface.
페드로: 어댑터는 다른 인터페이스를 이용하죠.

Eve: But from implementation perspective all these pattern are the same, wrap something and delegate calls to wrapper. "Wrapper" could be a good name for these patterns.
이브: 하지만 구현의 관점에서 보면 이런 패턴들은 모두 같아요. 즉, 어떤 것을 랩핑하고 랩퍼가 그것을 호출하죠. 그래서 "랩퍼"가 이런 패턴들에 더 맞는 이름일 수도 있어요.


Episode 23: Bridge
== 에피소드 23: 브릿지(Bridge) 패턴

[sidebar]
....
Girls from HR agency "Hurece's Sour Man" trying to identify candidates to their open job positions. The problem is jobs often created by customers, but requirements to the jobs are developed by HR. Provide them with a flexible way of collaborating.
Hurece's Sour Man의 채용 대행사 여직원들이 구인 요청에 맞는 후보들를 확인하고 있다. 문제는 직무는 고객들이 만드는데, 자격 요건은 채용 대행사에서 만든다는 것이다. 그들이 유연하게 협업할 수 있는 방법을 제공하라.
....

Eve: I don't understand the problem.
이브: 문제를 이해하지 못 하겠어요.

Pedro: I have a bit of background. They have a very strange system which defines job requirements as an interface.
페드로: 저는 조금 경험이 있어요. 채용 대행사의 시스템이 아주 이상한데요, 자격 요건들을 인터페이스로 정의해요.

[source, java]
....
interface JobRequirement {
    boolean accept(Candidate c);
}
....

Pedro: Every specific requirement implemented as a new subclass of this.
페드로: 모든 구체적인 자격 요건은 이 인터페이스를 구현한 것이에요.


[source, java]
....
class JavaRequirement implements JobRequirement {
    public boolean accept(Candidate c) {
        return c.hasSkill("Java");
    }
}

class Experience10YearsRequirement implements JobRequirement {
    public boolean accept(Candidate c) {
        return c.getExperience() >= 10;
    }
}
....

Eve: I've got an idea.
이브: 무슨 말인지 알겠어요.

Pedro: Take into account, this requirement hierarchy is designed by HR Department.
페드로: 여기서 고려해야 할 점은, 이 자격 요건의 계층도가 채용 대행사에서 설계된다는 거죠.

Eve: Ok.
이브: 그렇군요.

Pedro: And they have a Job hierarchy, where each specific job is subclass as well.
페드로: 그리고 ``Job`` 계층도가 있는데요, 또한 특정 직무(job)들은 이 ``Job``의 서브 클래스들이죠.

Eve: Why do they need a class for each job? It should be an object.
이브: 왜 각 직무마다 클래스가 있어야 되죠? 그건 객체여야 해요.

Pedro: The system was designed when classes were more popular than objects, so live with this.
페드로: 이 시스템은 객체보다는 클래스가 더 인기가 있을 때 설계되었죠. 그래서 여지껏 그대로에요.

Eve: Class were popular than objects?!
이브: 클래스가 객체보다 인기가 있었다고요?!

Pedro: Yes, listen and don't interrupt me. Jobs with requirements is completely separate hierarchy, and it is developed by customers. We introduce pattern Bridge to separate these two hierarchies and allow them live independently.
페드로: 네, 잘 들어요. 자격 요건이 있는 직무는 완전히 분리된 계층도인데요, 그것은 고객에 의해 개발돼요. 그래서 이 두 계층도를 브릿지 패턴으로 분리해서, 각자가 독자적으로 유지되도록 해보죠.


[source, java]
....
abstract class Job {
    protected List<? extends JobRequirement> requirements;

    public Job(List<? extends JobRequirement> requirements) {
        this.requirements = requirements;
    }

    protected boolean accept(Candidate c) {
        for (JobRequirement j : requirements) {
            if (!j.accept(c)) {
                return false;
            }
        }
        return true;
    }
}

class CognitectClojureDeveloper extends Job {
    public CognitectClojureDeveloper() {
        super(Arrays.asList(
                  new ClojureJobRequirement(),
                  new Experience10YearsRequirement()
        ));
    }
}
....

Eve: So where is the bridge?
이브: 그래서 브리지는 어디에 있죠?

Pedro: JobRequirement, JavaRequirement, ExperienceRequirement is one hierarchy, yes?
페드로: ``JobRequirement``, ``JavaRequirement``, ``ExperienceRequirement``이 한 계층도죠?

Eve: Yes.
이브: 네.

Pedro: Job, CongnitectClojureDeveloperJob, OracleJavaDeveloperJob is another hierarchy.
페드로: ``Job``, ``CongnitectClojureDeveloperJob``, ``OracleJavaDeveloperJob``이 또 다른 계층도죠.

Eve: Oh, now I see. A link from Job to JobRequirement is a bridge.
이브: 오, 이제 알겠어요. ``Job``과 ``JobRequirement``의 링크가 브릿지네요.

Pedro: Exactly! This is how HR can use this system to find candidate matches.
페드로: 맞아요! 이것이 채용 대행사가 이 시스템을 이용해서 후보자를 찾는 방법이예요.


[source, java]
....
Candidate joshuaBloch = new Candidate();
(new CognitectClojureDeveloper()).accept(joshuaBloch);
(new OracleSeniorJavaDeveloper()).accept(joshuaBloch);
....

Pedro: Here is the point. Customers use Job as abstraction and JobRequirement as an implementation. They just create a job with descriptions or so, and HR is responsible to convert these descriptions into specific set of JobRequirement objects.
페드로: 여기에 포인트가 있어요. 고객은 ``Job`` 은 추상으로, ``JobRequirement``는 구현으로 사용하죠. 고객들은 단지 직무(job)에 설명을 달아서 만들고, 채용 대행사는 그 설명을 특정 JobRequirement의 집합으로 바꾸죠.

Eve: Got it.
이브: 알겠어요.

Pedro: So as far as I understand, clojure could mimic this pattern by using defprotocol and defrecord?
페드로: 제가 지금까지 이해한 바로는 클로저는 이 패턴을 ``defprotocol``과 ``defrecord``로 흉내낼 수 있겠네요.

Eve: Yes, but I want to revisit the problem.
이브: 네, 하지만 이 문제 자체를 다시 보고 싶어요

Pedro: What's wrong?
페드로: 뭐가 잘못되었나요?

Eve: Here is we have a static flow: customer create job positions, human resources convert job position to a set of requirements and run a script against their candidates database to find a matches.
이브: 여기에는 일정한 절차가 있어요. 고객은 job 포지션을 만들고, 채용 대행사는 job 포지션을 자격 요건의 집합으로 바꾸고, 그들의 후보자 데이타베이스에서 맞는 사람들 고르는 스크립트를 실행합니다.

Pedro: Correct.
페드로: 맞아요.

Eve: So there is already dependency, HR can't do anything without open job positions.
이브: 그래서 이미 의존성이 있는 거죠. 왜냐하면 채용 대행사가 채용 직무 없이는 아무것도 할 수 없으니까요.

Pedro: Well, yes. But they can develop a set of structured requirements without knowing what open positions might be.
페드로: 글쎄요, 네. 하지만 채용 대행사는 자격 요건 체계를 만들 수 있어요. 채용 직무가 무엇인지 몰라도.

Eve: For what purpose?
이브: 왜 그렇게 해야 하죠?

Pedro: Later this can be reused by Job creators, so HR avoid doing the same work twice.
페드로: 나중에 이것은 ``Job`` 생성자에서 재사용할 수 있고, 그래서 채용 대행사는 같은 일을 두 번 하지 않아도 돼요.

Eve: Okay, got it, but this problem is artificial. Basically what we need is a way to colaborate between abstraction and implementation.
이브: 오케이, 알겠어요, 하지만 이 문제는 인위적이에요. 기본적으로 우리가 필요한 것은 추상과 구체 사이의 협업 방법입니다.

Pedro: Maybe, but I want to see your clojure way solution for that specific problem using bridge pattern.
페드로: 아마도요. 하지만 브릿지 패턴으로 이 특수한 문제를 클로저로 어떻게 푸는지 알고 싶어요.

Eve: Easy. Let's use adhoc hierarchies.
이브: 쉽죠. adhoc 계층도를 사용합시다.

Pedro: For abstractions?
페드로: 추상용 계층도인가요?

Eve: Yes, jobs hierarchy is abstraction, and people need just to enhance hierarchy.
이브: 네, job 계층도는 추상이죠, 그리고 사람들은 계층도를 보강할 필요가 있어요.


[source, clojure]
....
;; abstraction

(derive ::clojure-job ::job)
(derive ::java-job ::job)
(derive ::senior-clojure-job ::clojure-job)
(derive ::senior-java-job    ::java-job)
....

Eve: HR department are like developers, they provide implementation for this abstraction.
이브: 채용 대행사는 개발자들과 같이 마찬가지로, 이 추상의 구현을 제공합니다.


[source, clojure]
....
;; implementation

(defmulti accept :job)

(defmethod accept :java [candidate]
  (and (some #{:java} (:skills candidate))
       (> (:experience candidate) 1)))
....

Eve: Later, when new jobs are created, but requirements are not yet developed and no accept method implementation for this type of job, we fallback using adhoc hierarchy.
이브: 나중에, 새 채용 직무가 만들어졌는데 자격 요건은 개발되어 있지 않고, 그러한 job 타입을 위한 accept 메소드 구현도 없으면, adhoc 계층도의 기존 accept들이 사용돼요.

Pedro: Hm?
페드로: 흠?

Eve: Assume someone created a new ::senior-java as a child of ::java job.
이브: 누군가 새로운 ::senior-java를 :java의 일의 자식으로 만들었다고 합시다.

Pedro: Oh, and if HR not provided accept implementation for dispatch value ::senior-java, method with dispatch value ::java will be called, yes?
페드로: 오, 그리고 채용 대행사는 분기값이 ::senior-java인 accept 메소드 구현을 제공하지 않으면, 분기값이 ::java인 메소드가 호출되는 건가요?

Eve: You learning so fast.
이브: 당신은 빠르게 배우는 군요.

Pedro: But is it real bridge pattern?
페드로: 하지만 이것이 정말 브릿지 패턴인가요?

Eve: There is no bridge here, but abstraction and implementation can live independently.
이브: 여기에는 브릿지가 없어요, 하지만 추상과 구체가 독립적으로 유지될 수 있습니다.

The End.
끝.

Cheatsheet (instead of conclusion)
치트 쉬트(결론을 대신하며)

It is very confusing to understand patterns, which often presented in object-oriented way with bunch of UML diagrams, fancy nouns and exist to solve language-specific problems, so here is a revisited mini cheatsheet, which helps you to understand patterns by analogy.
패턴을 이해한다는 것은 상당히 혼동스런 작업인데, 흔히 UML 다이어그램이나 이상한 이름들을 사용해서 객체지향 방식으로 제시되거나, 특정 언어에 국한한 문제를 풀기 위한다거나 하기 때문이다. 그래서 여기에 작은 치트 쉬트를 공안했는데, 유삿성을 통해 패턴을 이해하는데 도움이 될 것이다.

Command - function
Strategy - function, which accepts function
State - strategy, depends on state
Visitor - multiple dispatch
Template Method - strategy with defaults
Iterator - sequence
Memento - save and restore
Prototype - immutability
Mediator - reduce coupling
Observer - function, which calls after another function
Interpreter - set of functions to process a tree
Flyweight - cache
Builder - optional arguments
Facade - single point of access
Singleton - global variable
Chain of Responsibility - function composition
Composite - tree
Factory Method - strategy for creating objects
Abstract Factory - strategy for creating set of related objects
Adapter - wrapper, same functionality, different type
Decorator - wrapper, same type, new functionality
Proxy - wrapper, function composition
Bridge - separate abstraction and implementation

커맨드 패턴 - 함수
전략 패턴 - 함수를 인수로 받는 함수.
상태 패턴 - 상태에 의존하는 전략 패턴.
방문자 패턴 - 다중 디스패치.
템플릿 메소드 패턴 - 기본 값을 포함한 전략 패턴.
이터레이터 패턴 - 시퀀스
메멘토 패턴 - 저장과 복구
관찰자 패턴 - 다른 함수뒤에 호출되는 함수.
인터프리터 패턴 - 트리를 처리하는 함수들.
플라이웨이트 패턴 - 캐쉬.
빌더 패턴 - 선택 인수.
책임 연쇄 패턴 - 함수 합성.
합성 패턴 - 트리
팩토리 메소드 패턴 - 객체 생성 전략.
추상 팩토리 패턴 - 관련 객체 생성 전략.
어댑터 패턴 - 랩퍼, 같은 기능들, 다양한 타입.
데코레이터 패턴 - 랩퍼, 같은 타입, 새로운 기능.
프록시 패턴 - 랩퍼, 함수 합성.
브릿지 패턴 - 추상과 구체의 분리.

Cast
등장 인물들.

A long time ago in a galaxy far, far away...
아주 오래전 우주 저 멀리 먼 곳에…

With the lack of imagination all characters and names are just anagrams.
상상력의 부족으로 인해 모든 캐릭터들과 이름들은 단지 다음과 같이 회문(anagram)으로 만들었다.

Pedro Veel - Developer
Eve Dopler - Developer
Serpent Hill & R.E.E. - Enterprise Hell
Sven Tori - Investor
Karmen Git - Marketing
Natanius S. Selbys - Business Analyst
Mech Dominore Fight Saga - Heroes of Might and Magic
Kent Podiololis - I don't like loops
Chad Bogue - Douchebag
Dex Ringeus - UX Designer
Veerco Wierde - Code Review
Dartee Hebl - Heartbleed
Bertie Prayc - Cyber Pirate
Cristopher, Matton & Pharts - Important Charts & Reports
Tuck Brass - Starbucks
Eugenio Reinn Jr. - Junior Engineer
Feverro O'Neal - Forever Alone
A Profit NY - Profanity
Bella Hock - Black Hole
Sir Dry Bang - Angry Birds
Saimank Gerr - Risk Manager
Deam Evil - Medieval
Podrea Vesper - Eavesdropper
Deren Bart - Bartender
Hurece's Sour Man - Human Resources

P.S. I've started to write this article more than 2 years ago. Time has passed, things have changed and even Java 8 was released.

P.S. 나는 이 기사의 작성을 2년 훨씬 전부터 시작했다. 시간을 흘러, 모든 것이 변해 자바 8이 나왔다.

clojure programming java story patterns
클로저 프로그래밍 자바 이야기 패턴

mishadoff
18 December 2015
Code Golf: New Year Tree →← Littlepot: Autofilled Cache

random thoughts about programming, math and life | mishadoff Design by Mark Reid | Powered by Jekyll


