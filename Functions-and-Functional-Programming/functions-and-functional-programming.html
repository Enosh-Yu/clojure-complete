<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]-->
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 1.5.3">
<title>Funcions and Functional Programming</title>
<link rel="stylesheet" href="..//my-asciidoctor.css">
<link rel="stylesheet" href="..//coderay-asciidoctor.css">
</head>
<body class="article">
<div id="header">
<h1>Funcions and Functional Programming</h1>
</div>
<div id="content">
<div class="sect1">
<h2 id="_함수형_언어란_무엇인가">1. 함수형 언어란 무엇인가?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>다음의 조건 네 가지를 충족시키면, 그 함수는 일급 함수(fisrt-class function)라고 부르고,
일급 함수를 지원하는 언어는 '전통적인 의미&#8217;에서의 함수형 언어라고 부를 수 있다.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>함수 객체를 변수에 대입할 수 있다.</p>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">def</span> <span class="function">double</span> (<span class="keyword">fn</span> [a] (<span class="keyword">*</span> <span class="integer">2</span> a)))   <span class="comment">; </span><b class="conum">(1)</b>

(<span class="keyword">double</span> <span class="integer">10</span>)    <span class="comment">; =&gt; 20</span>

(<span class="keyword">def</span> <span class="function">double2</span> <span class="keyword">double</span>)

(double2 <span class="integer">10</span>)   <span class="comment">; =&gt; 20</span></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>특수 형식(special form) <code>fn</code>을 이용해 먼저 함수 객체를 생성한 후, 이 객체를
<code>double</code>이라는 심볼에 바인딩한다.</p>
</li>
</ol>
</div>
</li>
<li>
<p>함수 객체를 함수의 인수로 전달할 수 있다.</p>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">defn</span> <span class="function">calc</span> [op a b]
  (op a b))

(calc <span class="keyword">+</span> <span class="integer">10</span> <span class="integer">20</span>)   <span class="comment">; =&gt; 30   </span><b class="conum">(1)</b>
(calc <span class="keyword">*</span> <span class="integer">10</span> <span class="integer">20</span>)   <span class="comment">; =&gt; 200</span></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>함수 객체 <code>+</code>를 <code>calc</code> 함수의 첫 번째 인수로 넘긴다.</p>
</li>
</ol>
</div>
</li>
<li>
<p>함수 객체를 함수의 반환값으로 반환할 수 있다.</p>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">defn</span> <span class="function">operator</span> [op]
  (<span class="keyword">cond</span>
    (<span class="keyword">=</span> op <span class="symbol">:plus</span>)  <span class="keyword">+</span>     <span class="comment">; </span><b class="conum">(1)</b>
    (<span class="keyword">=</span> op <span class="symbol">:minus</span>) <span class="keyword">-</span>))   <span class="comment">; </span><b class="conum">(1)</b>

((operator <span class="symbol">:plus</span>) <span class="integer">10</span> <span class="integer">20</span>)    <span class="comment">; =&gt; 30</span>
((operator <span class="symbol">:minus</span>) <span class="integer">10</span> <span class="integer">20</span>)   <span class="comment">; =&gt; -10</span></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>함수 객체 <code>+</code> 또는 <code>-</code>를 함수의 반환값으로 반환한다.</p>
</li>
</ol>
</div>
</li>
<li>
<p>함수 객체를 동적으로 생성할 수 있다.</p>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">defn</span> <span class="function">multiple</span> [n]
  (<span class="keyword">fn</span> [a]   <span class="comment">; </span><b class="conum">(1)</b>
    (<span class="keyword">*</span> n a)))

(<span class="keyword">def</span> <span class="function">double</span> (multiple <span class="integer">2</span>))
<span class="comment">; =&gt; #&lt;Var@4340684b: #object[user$multiple$fn__12286 0x26a894a2]&gt;</span>

(<span class="keyword">def</span> <span class="function">triple</span> (multiple <span class="integer">3</span>))
<span class="comment">; =&gt; #&lt;Var@fc4d31e: #object[user$multiple$fn__12286 0x1a4b7c5d]&gt;</span>

(<span class="keyword">double</span> <span class="integer">10</span>)   <span class="comment">; =&gt; 20</span>
(triple <span class="integer">10</span>)   <span class="comment">; =&gt; 30</span></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>함수를 동적으로 생성해 반환한다. 특수 형식 <code>fn</code>이 수행될 때마다 새로운 함수 객체가
생성된다.</p>
</li>
</ol>
</div>
</li>
</ol>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
특히 위의 두 번째와 세 번째 조건을 충족시키는 함수를 고차 함수(higher-order
     function)라고 부른다.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>오늘날 대부분의 언어가 함수형 언어의 영향을 받아, 위의 네 가지 조건을 모두 지원하거나
일부를 지원하고 있다. 그래서 루비나 파이썬, 심지어는 자바스크립트 언어마저도 위의 조건들을
모두 충족하고 있다. 그렇다면 이 세상은 이미 함수형 언어가 지배하고 있는 것인가? 함수형
언어를 어떻게 정의하느냐에 따라 의견이 달라질 수 있겠지만, 클로저 언어의 입장에서는 그렇게
보지 않는다. '현대적인 의미&#8217;에서, 즉 진정한 의미에서의 함수형 언어는 위의 네 가지 조건
이외에 한 가지 조건을 더 충족시켜야 하는데, 그것은 바로 클로저나 해스켈처럼
불변형(immutable) 자료 구조를 기본적으로 지원해야 한다는 것이다.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_주요_함수들">2. 주요 함수들</h2>
<div class="sectionbody">
<div class="paragraph">
<p>아래의 함수들 중 일부는 반환값으로 transducer를 반환한다. transducer에 대해서는
<a href="../Transducers/transducers.html">Transducers</a> 장에서 자세히 설명할 것이므로,
이곳에서는 함수 설명의 완결성을 위해 단순히 사용 예를 보여주는 데 그칠 것이다.</p>
</div>
<div class="sect2">
<h3 id="_map">2.1. map</h3>
<div class="paragraph">
<p>함수형 언어에서는 다음의 자바 코드에서처럼 index를 증가시키며 반복문을 실행하는 경우가
극히 드물다.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">import</span> <span class="include">java.util.Arrays</span>;

<span class="directive">public</span> <span class="type">class</span> <span class="class">Sample</span> {
    <span class="directive">public</span> <span class="directive">static</span> <span class="type">void</span> main(<span class="predefined-type">String</span><span class="type">[]</span> args) {
        <span class="type">int</span><span class="type">[]</span> array1 = {<span class="integer">0</span>, <span class="integer">1</span>, <span class="integer">2</span>, <span class="integer">3</span>, <span class="integer">4</span>};
        <span class="type">int</span><span class="type">[]</span> array2 = array1;

        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="integer">0</span>; i &lt; array1.length; i++) {   <b class="conum">(1)</b>
            array1[i] += <span class="integer">1</span>;                         <b class="conum">(2)</b>
        }

        <span class="predefined-type">System</span>.out.println(<span class="predefined-type">Arrays</span>.toString(array1));   <span class="comment">// [1, 2, 3, 4, 5]</span>
        <span class="predefined-type">System</span>.out.println(<span class="predefined-type">Arrays</span>.toString(array2));   <span class="comment">// [1, 2, 3, 4, 5]</span>
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>반복을 수행하는 부분이다.</p>
</li>
<li>
<p>실제 일을 수행하는 부분이다.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>위의 코드가 지니고 있는 문제점을 지적해 보자.</p>
</div>
<div class="paragraph">
<p>첫 번째 문제점은, 반복문을 처리할 때 '반복을 수행하는 부분&#8217;과 '실제 일을 수행하는 부분&#8217;을
분리할 수 없어, '반복을 수행하는 부분&#8217;을 매번 코딩해 주어야 한다는 것이다. 이 둘을 분리할
수 있다면, '반복을 수행하는 부분&#8217;을 매번 코딩할 필요가 없어진다. 컴퓨터가 가장 잘 하는
일이 인간을 대신해 단순한 일을 반복해 처리해 주는 것인데, 정작 그런 프로그램을 코딩하고
있는 프로그래머들은 단순 반복적인 코딩을 당연히 여기고 있다는 사실은 일종의 아이러니가
아닐 수 없다. 클로저에서는 이러한 문제점을 고차 함수(HOF: Higher Order Functions)를 통해
해결한다. 고차 함수는 함수 객체를 인수로 넘기는 함수를 말한다.</p>
</div>
<div class="paragraph">
<p>두 번째 문제점은, <code>array1</code> 변수를 참조하고 있는 <code>array2</code> 변수의 값도 함께 변경되었다는
것이다. 이것이 의도한 결과라면 문제가 안되겠지만, 의도하지 않은 것이라면 버그를 초래할
가능성이 높다. 실제로 프로그래밍할 때 주의해서 프로그래밍하지 않으면, 의도하지 않은
레퍼런스의 참조로 인한 버그는 흔한 일이다. 클로저에서는 이런 문제점을 불변값(immutable
value)을 통해 해결한다.</p>
</div>
<div class="paragraph">
<p>고차 함수 중에서 가장 많이 사용되는 <code>map</code> 함수를 통해서 이를 확인해 보자.</p>
</div>
<div class="listingblock">
<div class="title">map 형식</div>
<div class="content">
<pre>(map f coll*)
=&gt; lazy-seq</pre>
</div>
</div>
<div class="paragraph">
<p><code>map</code> 함수는 다음과 같이 수학에서 한 집합에서 다른 집합으로 바꾸는 작업을 한다. <code>f</code>는
<code>coll</code>의 각 요소에 적용된다.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>   X                 Y
 +----+   (f x1)   +----+
 | x1 |  -------&gt;  | y1 |
 |    |   (f x2)   |    |
 | x2 |  -------&gt;  | y2 |
 |    |   (f x3)   |    |
 | x3 |  -------&gt;  | y3 |
 |    |   (f x4)   |    |
 | x4 |  -------&gt;  | y4 |
 +----+            +----+</pre>
</div>
</div>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<div class="title">Caution</div>
</td>
<td class="content">
<div class="paragraph">
<p><code>map</code> 함수는 맵 자료형을 만드는 함수가 아닌 것에 주의한다. 요소들을 인수로 받아 맵
자료형을 만드는 함수는 <code>hash-map</code>이다.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">hash-map</span> <span class="symbol">:a</span> <span class="integer">1</span> <span class="symbol">:b</span> <span class="integer">2</span>)   <span class="comment">;=&gt; {:b 2, :a 1}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>참고로, <code>set</code> 함수는 집합이 아닌 컬렉션 자료형을 집합 자료형으로 변환하는 역할을
수행한다. 요소들을 인수로 받아 집합 자료형을 만드는 함수는 <code>hash-set</code>이다.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure"><span class="comment">;; 벡터를 집합으로 변환한다.</span>
(<span class="keyword">set</span> [<span class="integer">1</span> <span class="integer">1</span> <span class="integer">2</span> <span class="integer">2</span> <span class="integer">3</span> <span class="integer">3</span> <span class="integer">4</span> <span class="integer">5</span>])   <span class="comment">;=&gt; #{1 4 3 2 5}</span>

<span class="comment">;; 집합의 요소들을 받아 집합을 생성한다.</span>
(<span class="keyword">hash-set</span> <span class="integer">1</span> <span class="integer">1</span> <span class="integer">2</span> <span class="integer">2</span> <span class="integer">3</span> <span class="integer">3</span> <span class="integer">4</span> <span class="integer">5</span>)
#{<span class="integer">1</span> <span class="integer">4</span> <span class="integer">3</span> <span class="integer">2</span> <span class="integer">5</span>}</code></pre>
</div>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>map</code> 함수 자체에 '반복을 수행하는 부분&#8217;이 이미 내장되어 있다. 그래서 아래의 코드에서 함수
인수로 들어가는 <code>inc</code>가 '실제 일을 수행하는 부분&#8217;만을 담당하게 된다. 고차 함수 자체가
'반복을 수행하는 부분&#8217;을 제공하고, 이 함수의 인수로 들어가는 함수 <code>inc</code>와 데이터 <code>a</code>가
'실제 수행해야 할 일&#8217;을 지정하고 있는 것이다. 고차 함수의 도입으로 인해, index를 순회하며
'반복을 수행하는 부분&#8217;를 더 이상 매번 작성할 필요가 없어진 것이다! 별 것 아닌 것 같지만,
코드에서 가능한 한 중복을 제거하는 것 자체가 프로그래밍에 상당히 중요한 요소임을
간과해서는 안된다. 한 두번 반복하는 것이야 문제될 것이 없겠지만, 프로그래머 일생에 결쳐
계속해서 반복해야 한다먼 이것은 큰 문제가 아닐 수 없다. 왜 같은 일을 굳이 반복해야 하는가?
그렇게 하지 않을 수 있는 방법이 있는데도 말이다.</p>
</div>
<div class="paragraph">
<p>그리고 <code>map</code> 함수에서 <code>a</code>의 값을 사용했지만, <code>a</code>의 값은 변경되지 않았다. 따라서
<code>a</code>를 참조하고 있는 <code>b</code>의 내용도 당연히 변하지 않았다. 클로저에서는 모든 값이
immutable value이다. 그래서 <code>(map inc a)</code>를 평가해 나온 값 <code>(1 2 3 4 5)</code>는 <code>a</code>의 값
<code>[0 1 2 3 4]</code>를 변경한 것이 아니라, 새로운 값을 생성한 것이다.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">def</span> <span class="function">a</span> [<span class="integer">0</span> <span class="integer">1</span> <span class="integer">2</span> <span class="integer">3</span> <span class="integer">4</span>])
(<span class="keyword">def</span> <span class="function">b</span> a)

(<span class="keyword">map</span> <span class="keyword">inc</span> a)   <span class="comment">;=&gt; (1 2 3 4 5)</span>

a             <span class="comment">;=&gt; [0 1 2 3 4]</span>
b             <span class="comment">;=&gt; [0 1 2 3 4]</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><code>map</code> 함수는 다음과 같이 <code>coll</code> 인수를 두 개 이상 받을 수도 있다. 이 경우에는 맨 먼저 각
컬렉션의 첫 번째 요소들을 모두 가져와 함수 <code>+</code>에 적용하고, 그 다음에는 각 컬렉션의 두
번쨰 요소들을 모두 가져와 함수에 적용하는 방식으로 계속 이어진다.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">map</span> <span class="keyword">+</span> [<span class="integer">1</span> <span class="integer">2</span> <span class="integer">3</span>] [<span class="integer">10</span> <span class="integer">20</span> <span class="integer">30</span>] [<span class="integer">100</span> <span class="integer">200</span> <span class="integer">300</span>])
<span class="comment">;=&gt; (111 222 333)</span>

<span class="comment">;; 즉, 다음을 실행한 결과와 같다.</span>
(<span class="keyword">list</span> (<span class="keyword">+</span> <span class="integer">1</span> <span class="integer">10</span> <span class="integer">100</span>) (<span class="keyword">+</span> <span class="integer">2</span> <span class="integer">20</span> <span class="integer">200</span>) (<span class="keyword">+</span> <span class="integer">3</span> <span class="integer">30</span> <span class="integer">300</span>))
<span class="comment">;=&gt; (111 222 333)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>제공되는 컬렉션의 요소 수가 다르면, 요소의 수가 가장 적은 컬렉션에 맞추어 반환한다.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">map</span> <span class="keyword">+</span> [<span class="integer">1</span> <span class="integer">2</span>] [<span class="integer">10</span> <span class="integer">20</span> <span class="integer">30</span>] [<span class="integer">100</span> <span class="integer">200</span> <span class="integer">300</span>])
<span class="comment">;=&gt; (111 222)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>다음과 같은 코드는 예외가 발생하는데, <code>inc</code> 함수는 인수를 한 개만 받는 함수이기
때문이다. 즉, <code>map</code> 함수에 제공되는 컬렉션의 개수가 세 개이면, 세 개의 인수를 받을 수 있는
함수가 <code>map</code> 함수의 첫 번째 인수 자리에 와야 한다.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">map</span> <span class="keyword">inc</span> [<span class="integer">1</span> <span class="integer">2</span> <span class="integer">3</span>] [<span class="integer">10</span> <span class="integer">20</span> <span class="integer">30</span>] [<span class="integer">100</span> <span class="integer">200</span> <span class="integer">300</span>])
<span class="comment">;&gt;&gt; ArityException Wrong number of args (3) passed to: core/inc</span>

 <span class="comment">;; 즉, 다음을 실행한 결과와 같기 때문에 예외가 발생한다.</span>
(<span class="keyword">list</span> (<span class="keyword">inc</span> <span class="integer">1</span> <span class="integer">10</span> <span class="integer">100</span>) (<span class="keyword">inc</span> <span class="integer">2</span> <span class="integer">20</span> <span class="integer">200</span>) (<span class="keyword">inc</span> <span class="integer">3</span> <span class="integer">30</span> <span class="integer">300</span>))
<span class="comment">;&gt;&gt; ArityException: Wrong number of args (3) passed to: core/inc</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><code>map</code>은 함수인 인수 한 개만을 받을 때에는 transducer를 반환한다. 당장은 다음의 예제가
이해가 안되더라도 일단은 그냥 넘어 가자. <a href="../Transducers/transducers.html">Transducers</a>
장에서 자세히 설명할 것이다.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">map</span> <span class="keyword">inc</span>)
<span class="comment">;=&gt; #function[clojure.core/map$fn--4549]</span>

(transduce (<span class="keyword">map</span> <span class="keyword">inc</span>) <span class="keyword">+</span> (<span class="keyword">range</span> <span class="integer">5</span>))
<span class="comment">;=&gt; 55</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>마지막으로 초보자들이 <code>map</code> 함수를 사용할 때 종종 겪는 실수를 한 가지 언급하고자
한다. 그것은 바로 <code>map</code>의 첫 번째 함수 인수 자리에 부수 효과(side effects)를 일으키는
함수를 사용하지 말라는 것이다. 이것은 lazy-seq를 반환하는 모든 클로저 함수에 해당하는
이야기이기도 하다.</p>
</div>
<div class="paragraph">
<p>다음의 예제를 실행하면, 기대와는 달리 숫자 <code>1 2 3</code>이 화면에 출력되지 않는다. 그 이유는
<code>map</code> 함수가 반환한 lazy-seq가 실현(realized)될 기회를 갖지 못하기 때문이다. lazy-seq는
실현될 기회를 갖지 못하면 영원히 실현되지 않는다.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">let</span> [<span class="keyword">num</span> [<span class="integer">1</span> <span class="integer">2</span> <span class="integer">3</span>]]
  <span class="comment">;; map 함수의 실행 결과로 lazy-seq가 반환되지만, 쓰여지지 않은채 그냥 버려진다.</span>
  <span class="comment">;; 즉, 실현될 기회를 갖지 못하게 된다. 따라서 println 함수가 호출될 기회기 없다.</span>
  (<span class="keyword">map</span> #(<span class="keyword">println</span> %) <span class="keyword">num</span>)
  (<span class="keyword">conj</span> <span class="keyword">num</span> <span class="integer">4</span>))
<span class="comment">;=&gt; [1 2 3 4]</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>반면에 아래의 코드에서는, <code>map</code> 함수가 마찬가지로 laz-seq를 반환하지만, 또한 <code>let</code>의
반환값으로도 반환되고 있다. 이후 이 반환값을 REPL(Read-Eval-Print-Loop)에서 출력하는
과정에서 실현될 기회를 갖게 되어, 숫자 <code>1 2 3</code>이 화면에 출력된다.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">let</span> [<span class="keyword">num</span> [<span class="integer">1</span> <span class="integer">2</span> <span class="integer">3</span>]]
  (<span class="keyword">map</span> #(<span class="keyword">println</span> %) <span class="keyword">num</span>))
<span class="comment">;&gt;&gt; 1</span>
<span class="comment">;&gt;&gt; 2</span>
<span class="comment">;&gt;&gt; 3</span>
<span class="comment">;=&gt; (nil nil nil)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>따라서 부수 효과가 주목적이라면, <code>map</code> 함수가 아니라 부수 효과를 위해 준비된 <code>doseq</code>을
사용해야 한다. 아울러 아래의 코드에서 <code>doseq</code>이 <code>(2 4 6)</code>의 결과를 반환할 것이라
예상하겠지만,<code>doseq</code>은 마지막 반환 결과를 무시하고, 무조건 <code>nil</code>을 반환한다는 점에
주목하자. 한 마디로 <code>doseq</code>은 오로지 부수 효과만을 수행할 목적으로 마련된 매크로라고
보면 된다.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">doseq</span> [<span class="keyword">num</span> [<span class="integer">1</span> <span class="integer">2</span> <span class="integer">3</span>]]
  (<span class="keyword">println</span> <span class="keyword">num</span>)
  (<span class="keyword">*</span> <span class="keyword">num</span> <span class="integer">2</span>))
<span class="comment">;&gt;&gt; 1</span>
<span class="comment">;&gt;&gt; 2</span>
<span class="comment">;&gt;&gt; 3</span>
<span class="comment">;=&gt; nil</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>부득이하게 <code>map</code> 함수를 부수 효과를 적용하는데 사용해야만 하는 상황이라면, lazy-seq를 강제로
실현해 주는 <code>dorun</code>을 이용하는 방법도 있다.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">let</span> [<span class="keyword">num</span> [<span class="integer">1</span> <span class="integer">2</span> <span class="integer">3</span>]]
  (<span class="keyword">dorun</span> (<span class="keyword">map</span> #(<span class="keyword">println</span> %) <span class="keyword">num</span>))
  (<span class="keyword">conj</span> <span class="keyword">num</span> <span class="integer">4</span>))
<span class="comment">;&gt;&gt; 1</span>
<span class="comment">;&gt;&gt; 2</span>
<span class="comment">;&gt;&gt; 3</span>
<span class="comment">;=&gt; [1 2 3 4]</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>그리고 클로저 1.7.0에서 새로 도입된 <code>run!</code> 함수를 사용할 수도 있다.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">let</span> [<span class="keyword">num</span> [<span class="integer">1</span> <span class="integer">2</span> <span class="integer">3</span>]]
  (run! #(<span class="keyword">println</span> %) <span class="keyword">num</span>)
  (<span class="keyword">conj</span> <span class="keyword">num</span> <span class="integer">4</span>))
<span class="comment">;&gt;&gt; 1</span>
<span class="comment">;&gt;&gt; 2</span>
<span class="comment">;&gt;&gt; 3</span>
<span class="comment">;=&gt; [1 2 3 4]</span></code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2015-12-29 15:24:42 KST
</div>
</div>
</body>
</html>