= Simple Data Types
:source-highlighter: coderay
:source-language: clojure
:sectnums:
:icons: font
:imagesdir: ../img

== Clojure Data Type Diagram

다음의 도표는 클로저의 모든 자료형들을 한 눈에 살펴볼 수 있도록 일목요연하게 정리한
것이다. 먼저 전체적인 지도를 마음 속에 두고 각 부분을 자세하게 살펴 나가는 것이 클로저를
빠르고 정확하게 이해하는 지름길이다. 각 자료형 옆에는 실제로 구현되어 있는 자바 클래스를
병기했다. 이 장에서는 단순 자료형(Simple values)들을 중심으로 살펴보고, 다음 장에서 복합
자료형인 Collection들을 살펴 보겠다.

[[clojure-data-type-diagram]]


[cols="1,1,2,6", width="60%", options="header"]
|===
|  |  ^| 클로저 타입 ^| 자바 클래스

.13+^.^|Immutables (= Values)

.9+^.^|Simple values
^| Integers
a| * java.lang.Long
   * clojure.lang.BigInt

^| Floats
a| * java.lang.Double
   * java.math.GigDecimal

^| Ratios
 | clojure.lang.Ratio

^| Strings    | java.lang.String

^| Characters | java.lang.Character

^| Symbols    | clojure.lang.Symbol

^| Keywords   | clojure.lang.Keyword

^| Booleans   | java.lang.Boolean

^| nil        | null


.4+^.^|Collections
^| Lists      | clojure.lang.PersistentList

^| Vectors    | clojure.lang.PersistentVector

^| Maps
a| * array-map: clojure.lang.PersistentArrayMap
   * hash-map: clojure.lang.PersistentHashMap
   * sorted-map: clojure.lang.PersistentTreeMap
^| Sets
a| * hash-set: clojure.lang.PersistentHashSet
   * sorted-set: clojure.lang.PersistentTreeSet

.4+^.^|Mutables (= References)

.4+^.^|Identities
^| Atoms      | clojure.lang.Atom

^| Refs       | clojure.lang.Ref

^| Agents     | clojure.lang.Agent

^| Vars       | clojure.lang.Var

|===





== 정수(Integers)

클로저에서 정수는 자기 자신으로 평가되는 값(value)이다. 즉, 아래에서 정수 ``17``을
평가하면 그 결과는 자기 자신인 ``17``이 된다.

[listing]
----
user> 17
17
----

`type` 함수를 이용하면, 해당 값이 어떤 자료형으로 구현되어 있는지를 직접 확인해 볼 수 있다.

[listing]
----
user> (type 17)
java.lang.Long
----

위의 결과에서도 알 수 있듯이, 클로저에서 정수형은 자바의 ``java.lang.Long``형으로,
기본(primitive) 자료형인 '64비트 부호있는 정수 long형'를 내부적으로 감싸고 있는 wrapper
class의 인스턴스이다.

CAUTION: 자바의 기본(primitive) 자료형인 ``long``형이 아니라, 레퍼런스(reference) 타입인
         ``java.lang.Long``형임에 주의하자. 레퍼런스 타입이므로, 컬렉션 자료형의 요소로
         쓰일 수 있게 된다.

정수 맨 앞에 숫자 ``0``이 있으면 8진수를 표시하고, `0x` 또는 ``0X``가 있으면 16진수를
표시한다.

[listing]
----
user> 010
8

user> 0x10
16

user> 0X10
16
----

클로저는 8진수와 16진수 이외에도, 2진수에서 36진수까지 표기할 수 있는 방법을 제공한다. `r`
또는 `R` 문자footnote:[radix의 준말이다.] 앞에 표현하고자 하는 진법을 나타내고, 그 뒤에
숫자를 표시하면 된다. 실제 숫자를 표시할 때, `0` -- `9`를 넘어가는 숫자는 알파벳 `a` --
`z` 또는 `A` -- `Z` 문자를 이용한다.

[listing]
----
user> 2r1111   ; 2진법
15

user> 3r11     ; 3진법
4

user> 8r11     ; 8진법
9

user> 16rFF    ; 16진법
255

user> 36r1z    ; 36진법
71
----

정수의 맨 뒤에 대문자 ``N``footnote:[``iNteger``의 ``N``을 의미한다.]을 붙이면,
``Long``형보다 큰 임의의 길이의 정수((arbitrary-precision integer)도 표현할 수 있다.

[listing]
----
user> 9999999999999999999999999999999999999999999999999999N
9999999999999999999999999999999999999999999999999999N
----

다음의 ``2N``은 ``java.lang.Long``형이 아니라, ``clojure.lang.BigInt``형이다.

[listing]
----
user> 2N
2N

user> (type 2N)
clojure.lang.BigInt
----

아주 큰 정수에 명시적으로 N을 붙이지 않아도, clojure.lang.BigInt형으로 자동 형변환된다.

[listing]
----
user> 9999999999999999999999999999999999999999999999999999
9999999999999999999999999999999999999999999999999999N
----


== 실수(Floating Point Numbers)

클로저에서 부동 소수점 실수 역시 자기 자신으로 평가되는 값(value)이다.
``java.lang.Double``형으로, '기본(primitive) 자료형 double'을 내부적으로 감싸고 있는
wrapper class의 인스턴스이다.

[listing]
----
user> 3.14
3.14

user> (type 3.14)
java.lang.Double
----

과학적 표기법(Scientific Notation)도 지원한다.

[listing]
----
user> 6.0221412927e23
6.0221412927E23
----

실수 뒤에 대문자 ``M``footnote:[원래는 ``deciMal``의 ``M``에서 비롯된 것이나, ``Money``의
``M``으로 이해하는 사람도 있다.]을 붙이면, 정확도가 보장되는 임의의 길이의
실수(arbitrary-precision signed floating point decimal)를 표현할 수 있다.

[listing]
----
user> 100.01M
100.01M

user> (type 100.01M)
java.math.BigDecimal

user> (* 100.01M 100)
10001.00M
----


== 분수 (Ratios)

클로저에서는 분수 자료형도 제공한다. 분자와 분모 사이에 슬래시(``/``) 기호를 사용해
표현한다. 이때 분자, 분모와 슬래시 기호 사이에는 공백이 없어야 한다.

[listing]
----
user> 1/3
1/3

user> 7/4
7/4

user> (type 2/3)
clojure.lang.Ratio
----

분자와 분모는 모두 정수형이어야 한다. 그렇지 않으면 예외가 발생한다.

[listing]
----
user> 2/3.5
;>> NumberFormatException Invalid number: 2/3.5

----

약분이 가능한 경우에는, 약분된 값이 반환된다.
[listing]
----
user> 2/4
1/2
----

분수의 정확한 연산이 보장된다.

[listing]
----
user> (+ 1/3 2/3)
1N

user> (* 1/10 10)
1N

user> (+ 1/3 1)
4/3
----

분수와 실수 사이의 연산 결과는 실수형이다.

[listing]
----
user> (+ 1/3 1.0)
1.3333333333333333
----

분수를 실수로 강제로 형변환하고 싶을 때에는 ``double``이나 ``float`` 함수를 사용한다.

[listing]
----
user> (double 1/3)
0.3333333333333333

user> (float 1/3)
0.33333334
----









.









